<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>黄河水澄的技术专栏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="黄河水澄的技术专栏">
<meta property="og:url" content="https://debugtheuniverse.github.io/index.html">
<meta property="og:site_name" content="黄河水澄的技术专栏">
<meta property="og:locale">
<meta property="article:author" content="Jim Huang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="黄河水澄的技术专栏" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">黄河水澄的技术专栏</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">分享有用的知识</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://DebugTheUniverse.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-OpenCV 特征匹配" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/01/OpenCV%20%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D/" class="article-date">
  <time class="dt-published" datetime="2024-04-01T07:04:04.768Z" itemprop="datePublished">2024-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/01/OpenCV%20%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D/">OpenCV 特征匹配</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="1-暴力匹配"><a href="#1-暴力匹配" class="headerlink" title="1. 暴力匹配"></a>1. 暴力匹配</h4><p>暴力匹配使用一些距离计算两组特征描述之间的匹配度</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img1 = cv.imread(<span class="string">&#x27;images/box.png&#x27;</span>,cv.IMREAD_GRAYSCALE) <span class="comment"># queryImage</span></span><br><span class="line">img2 = cv.imread(<span class="string">&#x27;images/box_in_scene.png&#x27;</span>,cv.IMREAD_GRAYSCALE) <span class="comment"># trainImage</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 ORB </span></span><br><span class="line"><span class="comment"># Initiate ORB detector</span></span><br><span class="line">orb = cv.ORB_create()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># find the keypoints and descriptors with ORB</span></span><br><span class="line">kp1, des1 = orb.detectAndCompute(img1,<span class="literal">None</span>)</span><br><span class="line">kp2, des2 = orb.detectAndCompute(img2,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create BFMatcher object</span></span><br><span class="line">bf = cv.BFMatcher(cv.NORM_HAMMING, crossCheck=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Match descriptors.</span></span><br><span class="line">matches = bf.<span class="keyword">match</span>(des1,des2)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Sort them in the order of their distance.</span></span><br><span class="line">matches = <span class="built_in">sorted</span>(matches, key = <span class="keyword">lambda</span> x:x.distance)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Draw first 10 matches.</span></span><br><span class="line">img3 = cv.drawMatches(img1,kp1,img2,kp2,matches[:<span class="number">15</span>],<span class="literal">None</span>,flags=cv.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS)</span><br><span class="line"> </span><br><span class="line">plt.imshow(img3),plt.title(<span class="string">&#x27;ORB&#x27;</span>),plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 SIFT</span></span><br><span class="line"><span class="comment"># Initiate SIFT detector</span></span><br><span class="line">sift = cv.SIFT_create()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># find the keypoints and descriptors with SIFT</span></span><br><span class="line">kp1, des1 = sift.detectAndCompute(img1,<span class="literal">None</span>)</span><br><span class="line">kp2, des2 = sift.detectAndCompute(img2,<span class="literal">None</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># BFMatcher with default params</span></span><br><span class="line">bf = cv.BFMatcher()</span><br><span class="line">matches = bf.knnMatch(des1,des2,k=<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Apply ratio test</span></span><br><span class="line">good = []</span><br><span class="line"><span class="keyword">for</span> m,n <span class="keyword">in</span> matches:</span><br><span class="line"> <span class="keyword">if</span> m.distance &lt; <span class="number">0.35</span>*n.distance:</span><br><span class="line">    good.append([m])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># cv.drawMatchesKnn expects list of lists as matches.</span></span><br><span class="line">img3 = cv.drawMatchesKnn(img1,kp1,img2,kp2,good,<span class="literal">None</span>,flags=cv.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS)</span><br><span class="line"> </span><br><span class="line">plt.imshow(img3),plt.title(<span class="string">&#x27;SIFT&#x27;</span>),plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="2-基于FLANN的匹配"><a href="#2-基于FLANN的匹配" class="headerlink" title="2. 基于FLANN的匹配"></a>2. 基于FLANN的匹配</h4><p>FLANN是近似最近邻的快速库.包含了针对大型高维特征快速最近邻搜索优化的算法集.在大数据集上比BFMatcher更好.<br>使用FLANN,需要传入索引字典<code>IndexParams</code>描述所用算法及其参数.如需要使用SIFT&#x2F;SURF等,传入如下内容</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLANN_INDEX_KDTREE = <span class="number">1</span></span><br><span class="line">index_params = <span class="built_in">dict</span>(algorithm = FLANN_INDEX_KDTREE, trees = <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>而使用ORB,使用如下,参数要自己调整,文档中建议的不一定最符合实际使用</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FLANN_INDEX_LSH = <span class="number">6</span></span><br><span class="line">index_params= <span class="built_in">dict</span>(algorithm = FLANN_INDEX_LSH,</span><br><span class="line">    table_number = <span class="number">6</span>, <span class="comment"># 12</span></span><br><span class="line">    key_size = <span class="number">12</span>, <span class="comment"># 20</span></span><br><span class="line">    multi_probe_level = <span class="number">1</span>) <span class="comment">#2</span></span><br></pre></td></tr></table></figure>
<p>第二个字典是SearchParams,定义应该递归遍历索引中的树的次数,这个值越高精度越高,但是同样会消耗更多的时间</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img1 = cv.imread(<span class="string">&#x27;images/box.png&#x27;</span>,cv.IMREAD_GRAYSCALE) <span class="comment"># queryImage</span></span><br><span class="line">img2 = cv.imread(<span class="string">&#x27;images/box_in_scene.png&#x27;</span>,cv.IMREAD_GRAYSCALE) <span class="comment"># trainImage</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Initiate SIFT detector</span></span><br><span class="line">sift = cv.SIFT_create()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># find the keypoints and descriptors with SIFT</span></span><br><span class="line">kp1, des1 = sift.detectAndCompute(img1,<span class="literal">None</span>)</span><br><span class="line">kp2, des2 = sift.detectAndCompute(img2,<span class="literal">None</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># FLANN parameters</span></span><br><span class="line">FLANN_INDEX_KDTREE = <span class="number">1</span></span><br><span class="line">index_params = <span class="built_in">dict</span>(algorithm = FLANN_INDEX_KDTREE, trees = <span class="number">5</span>)</span><br><span class="line">search_params = <span class="built_in">dict</span>(checks=<span class="number">50</span>) <span class="comment"># or pass empty dictionary</span></span><br><span class="line"> </span><br><span class="line">flann = cv.FlannBasedMatcher(index_params,search_params)</span><br><span class="line"> </span><br><span class="line">matches = flann.knnMatch(des1,des2,k=<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Need to draw only good matches, so create a mask</span></span><br><span class="line">matchesMask = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matches))]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># ratio test as per Lowe&#x27;s paper</span></span><br><span class="line"><span class="keyword">for</span> i,(m,n) <span class="keyword">in</span> <span class="built_in">enumerate</span>(matches):</span><br><span class="line"> <span class="keyword">if</span> m.distance &lt; <span class="number">0.7</span>*n.distance:</span><br><span class="line">    matchesMask[i]=[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line">draw_params = <span class="built_in">dict</span>(matchColor = (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),</span><br><span class="line"> singlePointColor = (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line"> matchesMask = matchesMask,</span><br><span class="line"> flags = cv.DrawMatchesFlags_DEFAULT)</span><br><span class="line"> </span><br><span class="line">img3 = cv.drawMatchesKnn(img1,kp1,img2,kp2,matches,<span class="literal">None</span>,**draw_params)</span><br><span class="line"> </span><br><span class="line">plt.imshow(img3,),plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="3-特征匹配与单应实现物体查找"><a href="#3-特征匹配与单应实现物体查找" class="headerlink" title="3. 特征匹配与单应实现物体查找"></a>3. 特征匹配与单应实现物体查找</h4><p>前述的匹配是在另一张图片中寻找目标物体的一些部分.使用<code>cv.findHomography()</code>,传入两图片的点,可以找到物体在两个图片中的视角转换. 然后可以用<code>cv.perspectiveTransform</code>找到目标.至少需要4个正确的点来找到这个转换矩阵.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">MIN_MATCH_COUNT = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">img1 = cv.imread(<span class="string">&#x27;images/box.png&#x27;</span>, cv.IMREAD_GRAYSCALE) <span class="comment"># queryImage</span></span><br><span class="line">img2 = cv.imread(<span class="string">&#x27;images/box_in_scene.png&#x27;</span>, cv.IMREAD_GRAYSCALE) <span class="comment"># trainImage</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Initiate SIFT detector</span></span><br><span class="line">sift = cv.SIFT_create()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># find the keypoints and descriptors with SIFT</span></span><br><span class="line">kp1, des1 = sift.detectAndCompute(img1,<span class="literal">None</span>)</span><br><span class="line">kp2, des2 = sift.detectAndCompute(img2,<span class="literal">None</span>)</span><br><span class="line"> </span><br><span class="line">FLANN_INDEX_KDTREE = <span class="number">1</span></span><br><span class="line">index_params = <span class="built_in">dict</span>(algorithm = FLANN_INDEX_KDTREE, trees = <span class="number">5</span>)</span><br><span class="line">search_params = <span class="built_in">dict</span>(checks = <span class="number">50</span>)</span><br><span class="line"> </span><br><span class="line">flann = cv.FlannBasedMatcher(index_params, search_params)</span><br><span class="line"> </span><br><span class="line">matches = flann.knnMatch(des1,des2,k=<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># store all the good matches as per Lowe&#x27;s ratio test.</span></span><br><span class="line">good = []</span><br><span class="line"><span class="keyword">for</span> m,n <span class="keyword">in</span> matches:</span><br><span class="line"> <span class="keyword">if</span> m.distance &lt; <span class="number">0.7</span>*n.distance:</span><br><span class="line">    good.append(m)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(good)&gt;MIN_MATCH_COUNT:</span><br><span class="line"> src_pts = np.float32([ kp1[m.queryIdx].pt <span class="keyword">for</span> m <span class="keyword">in</span> good ]).reshape(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"> dst_pts = np.float32([ kp2[m.trainIdx].pt <span class="keyword">for</span> m <span class="keyword">in</span> good ]).reshape(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> M, mask = cv.findHomography(src_pts, dst_pts, cv.RANSAC,<span class="number">5.0</span>)</span><br><span class="line"> matchesMask = mask.ravel().tolist()</span><br><span class="line"> </span><br><span class="line"> h,w = img1.shape</span><br><span class="line"> pts = np.float32([ [<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,h-<span class="number">1</span>],[w-<span class="number">1</span>,h-<span class="number">1</span>],[w-<span class="number">1</span>,<span class="number">0</span>] ]).reshape(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"> dst = cv.perspectiveTransform(pts,M)</span><br><span class="line"> </span><br><span class="line"> img2 = cv.polylines(img2,[np.int32(dst)],<span class="literal">True</span>,<span class="number">255</span>,<span class="number">3</span>, cv.LINE_AA)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"> <span class="built_in">print</span>( <span class="string">&quot;Not enough matches are found - &#123;&#125;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(good), MIN_MATCH_COUNT) )</span><br><span class="line"> matchesMask = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">draw_params = <span class="built_in">dict</span>(matchColor = (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="comment"># draw matches in green color</span></span><br><span class="line"> singlePointColor = <span class="literal">None</span>,</span><br><span class="line"> matchesMask = matchesMask, <span class="comment"># draw only inliers</span></span><br><span class="line"> flags = <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">img3 = cv.drawMatches(img1,kp1,img2,kp2,good,<span class="literal">None</span>,**draw_params)</span><br><span class="line"> </span><br><span class="line">plt.imshow(img3, <span class="string">&#x27;gray&#x27;</span>),plt.show()</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://debugtheuniverse.github.io/2024/04/01/OpenCV%20%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D/" data-id="cluglu6mb0001i8uk4q3bc161" data-title="OpenCV 特征匹配" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OpenCV 相机畸变校准" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/28/OpenCV%20%E7%9B%B8%E6%9C%BA%E7%95%B8%E5%8F%98%E6%A0%A1%E5%87%86/" class="article-date">
  <time class="dt-published" datetime="2024-03-28T09:24:44.689Z" itemprop="datePublished">2024-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/28/OpenCV%20%E7%9B%B8%E6%9C%BA%E7%95%B8%E5%8F%98%E6%A0%A1%E5%87%86/">OpenCV相机畸变校准</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>相机包含了径向畸变和切向畸变。<br>径向畸变可以让实际中的直线在图像中弯曲，这种效应离图像中心越远越强烈。<br>径向畸变表示为</p>
<center>
<img src="./assets/img/radial_dist.jpg" width="80%" height="80%">
</center>
切向畸变来自于镜片与传感器之间的平行度误差，导致有一些区域图像看起来比实际要近。
切向畸变表示为
<center>
<img src="./assets/img/tangential_dist.jpg" width="80%" height="80%">
</center>
因此需要找到如下畸变系数
<center>
<img src="./assets/img/dist_coef.jpg" width="50%" height="50%">
</center>

<p>此外，我们还需要获取相机的内参和外参。内参包括了焦距（f_x, f_y）和光学中心（c_x, c_y），可用来创建一个相机矩阵。而相机矩阵也是消除一个相机畸变需要的。相机矩阵是相机固有的属性，一旦求得，可以复用到同一相机的所有图片。</p>
<center>
<img src="./assets/img/camera_mtx.jpg" width="50%" height="50%">
</center>
外参对应了将3D点转换到一个坐标系的平移向量和旋转向量

<p>通常在立体视觉应用中，校正镜头畸变是必须的事情。校正的原理是，提供一些完好定义的样本图片（例如，棋盘图、圆点图），已知其上特征点的真实相对坐标，也知道对应点在图像上的坐标，就可以计算出来畸变系数。至少提供10张样本图片以确保好的效果。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>相机校正需要的输入是一系列3D真实点坐标和对应的2D图像坐标。在图像中找到2D坐标没有任何问题。但真实3D点坐标有点难了。为了简化，认为棋盘格都是在XY平面固定的，这样Z全是0，事情好办了起来。<br>在代码中,3D点是<code>object points</code>, 2D点是<code>image points</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, <span class="number">30</span>, <span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">objp = np.zeros((<span class="number">6</span>*<span class="number">9</span>, <span class="number">3</span>), np.float32)</span><br><span class="line">objp[:,:<span class="number">2</span>] = np.mgrid[<span class="number">0</span>:<span class="number">9</span>, <span class="number">0</span>:<span class="number">6</span>].T.reshape(-<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">objpoints = []  <span class="comment"># 真实世界的3D坐标</span></span><br><span class="line">imgpoints = []  <span class="comment"># 图像中的2D坐标</span></span><br><span class="line"></span><br><span class="line">images = glob.glob(<span class="string">&#x27;chessboard/*.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> images:</span><br><span class="line">    img = cv.imread(fname)</span><br><span class="line">    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找棋盘的角点</span></span><br><span class="line">    ret, corners = cv.findChessboardCorners(gray, (<span class="number">9</span>,<span class="number">6</span>),<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果找到了，加入目标点、图像点</span></span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">        objpoints.append(objp)</span><br><span class="line">        corners2 = cv.cornerSubPix(gray, corners, (<span class="number">11</span>,<span class="number">11</span>),(-<span class="number">1</span>,-<span class="number">1</span>),criteria)</span><br><span class="line">        imgpoints.append(corners2)</span><br><span class="line"></span><br><span class="line">        cv.drawChessboardCorners(img,(<span class="number">9</span>,<span class="number">6</span>),corners2,ret)</span><br><span class="line">        cv.imshow(<span class="string">&#x27;img&#x27;</span>, img)</span><br><span class="line">        cv.waitKey(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 校正 返回：ret、相机矩阵、扭曲系数、旋转向量s、平移向量s</span></span><br><span class="line">ret, mtx, dist, rvecs, tvecs = cv.calibrateCamera(objpoints, imgpoints, gray.shape[::-<span class="number">1</span>], <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储为npz文件，便于读取使用</span></span><br><span class="line">np.savez(<span class="string">&#x27;cameracalib&#x27;</span>,mtx=mtx, dist=dist, rvecs=rvecs, tvecs=tvecs)</span><br><span class="line">calib_file = np.load(<span class="string">&#x27;cameracalib.npz&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(calib_file[<span class="string">&#x27;mtx&#x27;</span>])</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">&#x27;chessboard/left12.jpg&#x27;</span>)</span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">newcameramtx, roi = cv.getOptimalNewCameraMatrix(calib_file[<span class="string">&#x27;mtx&#x27;</span>], calib_file[<span class="string">&#x27;dist&#x27;</span>], (w,h), <span class="number">1</span>, (w,h))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消除畸变</span></span><br><span class="line">dst = cv.undistort(img,mtx, dist, <span class="literal">None</span>, newcameramtx)</span><br><span class="line">x,y,w,h = roi</span><br><span class="line">dst1 = dst[y:y+h, x:x+w]</span><br><span class="line">cv.imshow(<span class="string">&#x27;ds1&#x27;</span>,dst1)</span><br><span class="line">cv.imwrite(<span class="string">&#x27;calibresult.png&#x27;</span>, dst1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种方法消除畸变</span></span><br><span class="line">mapx, mapy = cv.initUndistortRectifyMap(mtx, dist, <span class="literal">None</span>, newcameramtx, (w,h), <span class="number">5</span>)</span><br><span class="line">dst2 = cv.remap(img, mapx, mapy, cv.INTER_LINEAR)</span><br><span class="line">dst2 = dst2[y:y+h, x:x+w]</span><br><span class="line">cv.imshow(<span class="string">&#x27;ds2&#x27;</span>,dst2)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://debugtheuniverse.github.io/2024/03/28/OpenCV%20%E7%9B%B8%E6%9C%BA%E7%95%B8%E5%8F%98%E6%A0%A1%E5%87%86/" data-id="club3o6ez0000skukhea93hpf" data-title="OpenCV相机畸变校准" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OpenCV 特征提取" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/21/OpenCV%20%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/" class="article-date">
  <time class="dt-published" datetime="2024-03-21T08:49:51.831Z" itemprop="datePublished">2024-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/21/OpenCV%20%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/">OpenCV 特征提取与描述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="1-什么是特征"><a href="#1-什么是特征" class="headerlink" title="1. 什么是特征"></a>1. 什么是特征</h4><p>图像中的小区域，向周围小范围移动时变化最大，即特征。寻找到这些特征的过程叫做特征检测（Feature Detection）。<br>比如一个白色背景的矩形图像，位于四个角落的小区域是特征点，位于边线上的次要特征，位于纯色区域的没有特征</p>
<h4 id="2-Harris-角落检测"><a href="#2-Harris-角落检测" class="headerlink" title="2. Harris 角落检测"></a>2. Harris 角落检测</h4><p>寻找在全方向的（u,v）位移的亮度变化，形成函数，使用泰勒展开，推为矩阵M。创建一个分数R，取决于矩阵M的两个特征值之间的相对大小关系，判断为平区域、边界、角点</p>
<blockquote>
<p>R &#x3D; det(M) - k(trace(M))<sup>2</sup></p>
</blockquote>
<p>其中</p>
<ul>
<li>det(M) &#x3D; λ<sub>1</sub>λ<sub>2</sub></li>
<li>trace(M) &#x3D; λ<sub>1</sub> + λ<sub>2</sub></li>
<li>λ<sub>1</sub>和λ<sub>2</sub>是M的特征值</li>
</ul>
<p>代码使用<code>cv.cornerHarris()</code></p>
<ul>
<li>img -输入图像，灰度float32</li>
<li>blockSize -角点检测考虑的邻域大小</li>
<li>kSize -Sobel 微分使用的Aperture参数</li>
<li>k -Harris检测公式中的自由参数</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line">filename = <span class="string">&#x27;calibresult.png&#x27;</span></span><br><span class="line">img = cv.imread(filename)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"> </span><br><span class="line">gray = np.float32(gray)</span><br><span class="line">dst = cv.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#result is dilated for marking the corners, not important</span></span><br><span class="line">dst = cv.dilate(dst,<span class="literal">None</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Threshold for an optimal value, it may vary depending on the image.</span></span><br><span class="line">img[dst&gt;<span class="number">0.01</span>*dst.<span class="built_in">max</span>()]=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line"> </span><br><span class="line">cv.imshow(<span class="string">&#x27;dst&#x27;</span>,img)</span><br><span class="line"><span class="keyword">if</span> cv.waitKey(<span class="number">0</span>) &amp; <span class="number">0xff</span> == <span class="number">27</span>:</span><br><span class="line"> cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>如果要获得亚像素精度的焦点，使用cv.cornerSubPix()</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find centroids</span></span><br><span class="line">ret, labels, stats, centroids = cv.connectedComponentsWithStats(dst)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># define the criteria to stop and refine the corners</span></span><br><span class="line">criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, <span class="number">100</span>, <span class="number">0.001</span>)</span><br><span class="line">corners = cv.cornerSubPix(gray,np.float32(centroids),(<span class="number">5</span>,<span class="number">5</span>),(-<span class="number">1</span>,-<span class="number">1</span>),criteria)</span><br></pre></td></tr></table></figure>
<h4 id="3-Shi-Tomasi-角点检测-Good-Features-to-Track"><a href="#3-Shi-Tomasi-角点检测-Good-Features-to-Track" class="headerlink" title="3. Shi-Tomasi 角点检测 Good Features to Track"></a>3. Shi-Tomasi 角点检测 Good Features to Track</h4><p>将分数定义为了</p>
<blockquote>
<p>R &#x3D; min(λ<sub>1</sub>, λ<sub>2</sub>)</p>
</blockquote>
<p>若R大于某个阈值，则认为是角点。</p>
<p>使用<code>cv.goodFeaturesToTrack()</code></p>
<ul>
<li>输入图像</li>
<li>需要寻找的角点数目</li>
<li>0-1之间的质量等级</li>
<li>角点之间的最小欧式距离<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">corners = cv.goodFeaturesToTrack(gray,<span class="number">250</span>,<span class="number">0.01</span>,<span class="number">20</span>)</span><br><span class="line">corners = np.int0(corners)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> corners:</span><br><span class="line">    x,y = i.ravel()</span><br><span class="line">    cv.circle(img,(x,y),<span class="number">3</span>,<span class="number">255</span>,-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-SIFT-尺度不变特征转换"><a href="#4-SIFT-尺度不变特征转换" class="headerlink" title="4. SIFT 尺度不变特征转换"></a>4. SIFT 尺度不变特征转换</h4><p>小窗口中的角点图被放大后，用同样大的窗口观察看起来变得平滑了。SIFT中，分别进行尺度空间极值检测、关键点定位、方向赋值、关键点描述、关键点匹配。这个算法在2020年专利已经到期，可放心使用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">filename = <span class="string">&#x27;images/home.jpg&#x27;</span></span><br><span class="line">img = cv.imread(filename)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">sift = cv.SIFT_create()</span><br><span class="line">kp = sift.detect(gray,<span class="literal">None</span>)</span><br><span class="line"> </span><br><span class="line">img=cv.drawKeypoints(gray,kp,img)</span><br><span class="line"> </span><br><span class="line">cv.imwrite(<span class="string">&#x27;sift_keypoints.jpg&#x27;</span>,img)</span><br></pre></td></tr></table></figure>
<p><code>sift.detect()</code>可以输入mask指定寻找区域<br><code>cv.drawKeyPoints()</code>用于绘制关键点的圆圈，如果传入<code>flag=cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS</code>，会绘制关键点直径的圆圈并显示其方向。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img=cv.drawKeypoints(gray,kp,img,flags=cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)</span><br></pre></td></tr></table></figure>

<p>计算特征描述(Descriptor)</p>
<ol>
<li>已知关键点kp，用sift.compute(),&#96;&#96;kp, des &#x3D; sift.compute(gray, kp)</li>
<li>一步到位，用sift.detectdAndCompute()<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sift = cv.SIFT_create()</span><br><span class="line">kp, des = sift.detectAndCompute(gray,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
kp是关键点列表，des是numpy数组形状是（关键点数）*128</li>
</ol>
<p>通常获得了关键点和描述，我们就可以在之后的操作中匹配不同图片中的关键点了。</p>
<h4 id="5-SURF-快速鲁棒特征"><a href="#5-SURF-快速鲁棒特征" class="headerlink" title="5. SURF 快速鲁棒特征"></a>5. SURF 快速鲁棒特征</h4><p>SURF在每个步骤增加了很多特征，达到同样效果比SIFT快3倍，适用于带有模糊和旋转的图片，但不适用视角转变和光线变化的情况。</p>
<p>如何在OpenCV中还处于专利保护阶段，要想使用，需要卸载当前高版本，重新安装opencv-contrib-python&#x3D;&#x3D;3.4.2.17</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寻找SURF关键点和描述符并绘制</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;images/fly.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建SURF对象，可以在创建时指定参数也可以稍后设置参数</span></span><br><span class="line"><span class="comment"># 此处设置 Hessian阈值为 400</span></span><br><span class="line">sift = cv2.xfeatures2d.SIFT_create()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sift: &#x27;</span>, sift)</span><br><span class="line">surf = cv2.xfeatures2d.SURF_create(<span class="number">400</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;surf: &#x27;</span>, surf,</span><br><span class="line">      <span class="string">&#x27; \ndefaultParameter\thessianThreshold: &#x27;</span>, surf.getHessianThreshold(),</span><br><span class="line">      <span class="string">&#x27; upright: &#x27;</span>, surf.getUpright(),</span><br><span class="line">      <span class="string">&#x27; extended: &#x27;</span>, surf.getExtended(),</span><br><span class="line">      <span class="string">&#x27; descriptors: &#x27;</span>,surf.descriptorSize())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找SURF关键点和描述符</span></span><br><span class="line"><span class="comment"># kp:返回的关键点列表，des：numpy数组</span></span><br><span class="line">kp, des = surf.detectAndCompute(img, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 绘制关键点在图片上</span></span><br><span class="line">img2 = cv2.drawKeypoints(img, kp, <span class="literal">None</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">4</span>)</span><br><span class="line">plt.imshow(img2), plt.xticks([]), plt.yticks([]), plt.title(<span class="string">&#x27;more keypoints&#x27;</span>), plt.show()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;keypoints: &#x27;</span>, <span class="built_in">len</span>(kp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查当前Hessian阈值</span></span><br><span class="line"><span class="comment"># print(surf.getHessianThreshold())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整Hessian阈值，此处设置为50000，但一般最佳设置为300~500</span></span><br><span class="line">surf.setHessianThreshold(<span class="number">50000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; parameters\thessianThreshold: &#x27;</span>, surf.getHessianThreshold(),</span><br><span class="line">      <span class="string">&#x27; upright: &#x27;</span>, surf.getUpright(),</span><br><span class="line">      <span class="string">&#x27; extended: &#x27;</span>, surf.getExtended(),</span><br><span class="line">      <span class="string">&#x27; descriptors: &#x27;</span>,surf.descriptorSize())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再一次计算关键点和描述符</span></span><br><span class="line">kp, des = surf.detectAndCompute(img, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;keypoints: &#x27;</span>, <span class="built_in">len</span>(kp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制关键点在图片上</span></span><br><span class="line">img2 = cv2.drawKeypoints(img, kp, <span class="literal">None</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(img2), plt.xticks([]), plt.yticks([]), plt.title(<span class="string">&#x27;less than 50 keypoints&#x27;</span>), plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># U-SURF不会计算方向</span></span><br><span class="line"><span class="comment"># print(surf.getUpright())</span></span><br><span class="line">surf.setUpright(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; parameters\thessianThreshold: &#x27;</span>, surf.getHessianThreshold(),</span><br><span class="line">      <span class="string">&#x27; upright: &#x27;</span>, surf.getUpright(),</span><br><span class="line">      <span class="string">&#x27; extended: &#x27;</span>, surf.getExtended(),</span><br><span class="line">      <span class="string">&#x27; descriptors: &#x27;</span>,surf.descriptorSize())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新计算关键点和描述符，并绘制</span></span><br><span class="line">kp = surf.detect(img, <span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;keypoints: &#x27;</span>, <span class="built_in">len</span>(kp))</span><br><span class="line">img2 = cv2.drawKeypoints(img, kp, <span class="literal">None</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(img2), plt.xticks([]), plt.yticks([]), plt.title(<span class="string">&#x27;U-SURF&#x27;</span>), plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有方向显示在同一方向，它比以前快多了。如果您正在处理方向不成问题的情况（如全景缝合）等，使用U-SURF会更好。</span></span><br><span class="line"><span class="comment"># 寻找描述符的大小</span></span><br><span class="line"><span class="comment"># print(surf.descriptorSize())</span></span><br><span class="line"><span class="comment"># extended为false，默认为64D</span></span><br><span class="line"><span class="comment"># print(surf.getExtended())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置描述符为128D</span></span><br><span class="line">surf.setExtended(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; parameters\thessianThreshold: &#x27;</span>, surf.getHessianThreshold(),</span><br><span class="line">      <span class="string">&#x27; upright: &#x27;</span>, surf.getUpright(),</span><br><span class="line">      <span class="string">&#x27; extended: &#x27;</span>, surf.getExtended(),</span><br><span class="line">      <span class="string">&#x27; descriptors: &#x27;</span>,surf.descriptorSize())</span><br><span class="line"></span><br><span class="line">kp, des = surf.detectAndCompute(img, <span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;keypoints: &#x27;</span>,<span class="built_in">len</span>(kp))</span><br><span class="line">img2 = cv2.drawKeypoints(img, kp, <span class="literal">None</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(img2), plt.xticks([]), plt.yticks([]), plt.title(<span class="string">&#x27;128D res&#x27;</span>), plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码<a target="_blank" rel="noopener" href="https://juejin.cn/post/7023698517327609887">来自这</a></p>
<h4 id="6-FAST-快速角点检测方法"><a href="#6-FAST-快速角点检测方法" class="headerlink" title="6. FAST 快速角点检测方法"></a>6. FAST 快速角点检测方法</h4><p>比前几种方法快几倍，但对高噪音不鲁棒。有一个阈值参数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;images/blox.jpg&#x27;</span>, cv.IMREAD_GRAYSCALE) <span class="comment"># `&lt;opencv_root&gt;/samples/data/blox.jpg`</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Initiate FAST object with default values</span></span><br><span class="line">fast = cv.FastFeatureDetector_create()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># find and draw the keypoints</span></span><br><span class="line">kp = fast.detect(img,<span class="literal">None</span>)</span><br><span class="line">img2 = cv.drawKeypoints(img, kp, <span class="literal">None</span>, color=(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Print all default params</span></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;Threshold: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(fast.getThreshold()) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;nonmaxSuppression:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(fast.getNonmaxSuppression()) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;neighborhood: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(fast.getType()) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;Total Keypoints with nonmaxSuppression: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(kp)) )</span><br><span class="line"> </span><br><span class="line">cv.imwrite(<span class="string">&#x27;fast_true.png&#x27;</span>, img2)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Disable nonmaxSuppression</span></span><br><span class="line">fast.setNonmaxSuppression(<span class="number">0</span>)</span><br><span class="line">kp = fast.detect(img, <span class="literal">None</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;Total Keypoints without nonmaxSuppression: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(kp)) )</span><br><span class="line"> </span><br><span class="line">img3 = cv.drawKeypoints(img, kp, <span class="literal">None</span>, color=(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"> </span><br><span class="line">cv.imwrite(<span class="string">&#x27;fast_false.png&#x27;</span>, img3)</span><br></pre></td></tr></table></figure>

<h4 id="7-BRIEF-二元鲁棒独立基本特征"><a href="#7-BRIEF-二元鲁棒独立基本特征" class="headerlink" title="7. BRIEF 二元鲁棒独立基本特征"></a>7. BRIEF 二元鲁棒独立基本特征</h4><p>一种更快的特征描述与匹配方法，需要使用其他的方法检测到关键点，适用于CenSurE（STAR）方法</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;images/aero1.jpg&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Initiate FAST detector</span></span><br><span class="line">fast = cv.xfeatures2d.StarDetector_create()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Initiate BRIEF extractor</span></span><br><span class="line">brief = cv.xfeatures2d.BriefDescriptorExtractor_create()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># find the keypoints with STAR</span></span><br><span class="line">kp = fast.detect(img,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment"># compute the descriptors with BRIEF</span></span><br><span class="line">kp, des = brief.compute(img, kp)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>( brief.descriptorSize() )</span><br><span class="line"><span class="built_in">print</span>( des.shape )</span><br></pre></td></tr></table></figure>

<h4 id="8-ORB（Oriented-FAST-and-Rotated-BRIEF）"><a href="#8-ORB（Oriented-FAST-and-Rotated-BRIEF）" class="headerlink" title="8. ORB（Oriented FAST and Rotated BRIEF）"></a>8. ORB（Oriented FAST and Rotated BRIEF）</h4><p>没有专利，安全使用，更快更好。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;images/blox.jpg&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Initiate ORB detector</span></span><br><span class="line">orb = cv.ORB_create()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># find the keypoints with ORB</span></span><br><span class="line">kp = orb.detect(img,<span class="literal">None</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># compute the descriptors with ORB</span></span><br><span class="line">kp, des = orb.compute(img, kp)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># draw only keypoints location,not size and orientation</span></span><br><span class="line">img2 = cv.drawKeypoints(img, kp, <span class="literal">None</span>, color=(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), flags=<span class="number">0</span>)</span><br><span class="line">plt.imshow(img2), plt.show()</span><br></pre></td></tr></table></figure>

<p>具体使用直接看<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/db/d27/tutorial_py_table_of_contents_feature2d.html">官方教程</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://debugtheuniverse.github.io/2024/03/21/OpenCV%20%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/" data-id="clu1zw4kt0000oguk8svc9jox" data-title="OpenCV 特征提取与描述" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OpenCV 图像处理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/20/OpenCV%20%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2024-03-20T13:44:19.778Z" itemprop="datePublished">2024-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/20/OpenCV%20%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">OpenCV 图像处理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="1-更改图像颜色空间"><a href="#1-更改图像颜色空间" class="headerlink" title="1. 更改图像颜色空间"></a>1. 更改图像颜色空间</h5><p>使用<code>cv.cvtColor()</code>，输入：图像，方法（比如cv.COLOR_BGR2HSV）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)</span><br></pre></td></tr></table></figure>

<h5 id="2-几何转换操作"><a href="#2-几何转换操作" class="headerlink" title="2. 几何转换操作"></a>2. 几何转换操作</h5><p>调整图像大小</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"> </span><br><span class="line">res = cv.resize(img,<span class="literal">None</span>,fx=<span class="number">2</span>, fy=<span class="number">2</span>, interpolation = cv.INTER_CUBIC)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#OR</span></span><br><span class="line"> </span><br><span class="line">height, width = img.shape[:<span class="number">2</span>]</span><br><span class="line">res = cv.resize(img,(<span class="number">2</span>*width, <span class="number">2</span>*height), interpolation = cv.INTER_CUBIC)</span><br></pre></td></tr></table></figure>
<p>使用<code>cv.warpAffine()</code>平移图片;<br>使用<code>cv.getRotationMatrix2D()</code>获取2x3旋转矩阵，如旋转90度</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">rows,cols = img.shape</span><br><span class="line"> </span><br><span class="line"><span class="comment">#M = np.float32([[1,0,100],[0,1,50]]) # 平移矩阵</span></span><br><span class="line">M = cv.getRotationMatrix2D(((cols-<span class="number">1</span>)/<span class="number">2.0</span>,(rows-<span class="number">1</span>)/<span class="number">2.0</span>),<span class="number">90</span>,<span class="number">1</span>) <span class="comment"># 旋转矩阵</span></span><br><span class="line">dst = cv.warpAffine(img,M,(cols,rows)) <span class="comment"># 输入：图像，转换矩阵，尺寸（宽，高）</span></span><br><span class="line"> </span><br><span class="line">cv.imshow(<span class="string">&#x27;img&#x27;</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h5 id="3-仿射变换"><a href="#3-仿射变换" class="headerlink" title="3. 仿射变换"></a>3. 仿射变换</h5><p>在仿射变换中，原图中平行线在变换后仍然平行。<br>方法为使用<code>cv.getAffineTransform()</code>获取2x3的转换矩阵后传入<code>cv.warpAffine()</code><br>生成操作矩阵需要3组对应坐标</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">rows,cols,ch = img.shape</span><br><span class="line"> </span><br><span class="line">pts1 = np.float32([[<span class="number">50</span>,<span class="number">50</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">50</span>,<span class="number">200</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">10</span>,<span class="number">100</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">100</span>,<span class="number">250</span>]])</span><br><span class="line"> </span><br><span class="line">M = cv.getAffineTransform(pts1,pts2)</span><br><span class="line"> </span><br><span class="line">dst = cv.warpAffine(img,M,(cols,rows))</span><br><span class="line"> </span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Input&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Output&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h5 id="4-视角变换"><a href="#4-视角变换" class="headerlink" title="4. 视角变换"></a>4. 视角变换</h5><p>视角变换后直线还是直线。变换矩阵是3x3的，需要4组对应已知的坐标，其中不能存在3点共线，这样便能使用<code>cv.getPerspectiveTransform()</code>获得转换矩阵，然后矩阵传入<code>cv.warpPespective()</code>即可</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pts1 = np.float32([[<span class="number">56</span>,<span class="number">65</span>],[<span class="number">368</span>,<span class="number">52</span>],[<span class="number">28</span>,<span class="number">387</span>],[<span class="number">389</span>,<span class="number">390</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">300</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">300</span>],[<span class="number">300</span>,<span class="number">300</span>]])</span><br><span class="line"> </span><br><span class="line">M = cv.getPerspectiveTransform(pts1,pts2)</span><br><span class="line"> </span><br><span class="line">dst = cv.warpPerspective(img,M,(<span class="number">300</span>,<span class="number">300</span>))</span><br></pre></td></tr></table></figure>

<h5 id="5-阈值处理"><a href="#5-阈值处理" class="headerlink" title="5. 阈值处理"></a>5. 阈值处理</h5><p>使用<code>cv.threshold()</code>，输入：图像（灰度），阈值，最大值（超阈值的设定为此），方法<br>返回：使用阈值, 阈值处理的图</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">ret,thresh1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO_INV)</span><br><span class="line"> </span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>,<span class="string">&#x27;BINARY&#x27;</span>,<span class="string">&#x27;BINARY_INV&#x27;</span>,<span class="string">&#x27;TRUNC&#x27;</span>,<span class="string">&#x27;TOZERO&#x27;</span>,<span class="string">&#x27;TOZERO_INV&#x27;</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>,vmin=<span class="number">0</span>,vmax=<span class="number">255</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>自适应阈值<br><code>cv.ADAPTIVE_THRESH_MEAN_C</code> 阈值 &#x3D; 邻域均值 - C<br><code>cv.ADAPTIVE_THRESH_GAUSSIAN_C</code> 阈值 &#x3D; 邻域高斯加权和均值 - C<br>blockSize决定领域大小，C是从邻域均值或加权均值中减去的常数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">img = cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">ret,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">th2 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_MEAN_C,\</span><br><span class="line"> cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">th3 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,\</span><br><span class="line"> cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>, <span class="string">&#x27;Global Thresholding (v = 127)&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Adaptive Mean Thresholding&#x27;</span>, <span class="string">&#x27;Adaptive Gaussian Thresholding&#x27;</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"> plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"> plt.title(titles[i])</span><br><span class="line"> plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>大津二值化 Otsu’s Binarization<br>可以不需要选择一个数值作为阈值，从图像直方图确定全局最优阈值，该值通过最小化加权组内方差求得</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Otsu&#x27;s thresholding</span></span><br><span class="line">ret2,th2 = cv.threshold(img,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br></pre></td></tr></table></figure>

<h5 id="6-图像平滑（卷积）"><a href="#6-图像平滑（卷积）" class="headerlink" title="6. 图像平滑（卷积）"></a>6. 图像平滑（卷积）</h5><p><code>cv.filter2D()</code>实现卷积</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"> </span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.float32)/<span class="number">25</span>   <span class="comment"># 平均kernel</span></span><br><span class="line">dst = cv.filter2D(img,-<span class="number">1</span>,kernel)</span><br><span class="line"></span><br><span class="line">blr = cv.blur()</span><br><span class="line"> </span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Averaging&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>图像过滤模糊的一些常用函数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"> </span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.float32)/<span class="number">25</span></span><br><span class="line">dst = cv.filter2D(img,-<span class="number">1</span>,kernel)</span><br><span class="line"></span><br><span class="line">blr = cv.blur(img,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">g_blr = cv.GaussianBlur(img, (<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)   <span class="comment"># 高斯模糊：最后参数σx和σy</span></span><br><span class="line"></span><br><span class="line">m_blr = cv.medianBlur(img, <span class="number">5</span>)   <span class="comment"># 有效消除椒盐噪声</span></span><br><span class="line"></span><br><span class="line">bi_blr = cv.bilateralFilter(img,<span class="number">9</span>, <span class="number">75</span>, <span class="number">75</span>)  <span class="comment"># 由一个空间高斯方程和一个像素差异方程组成，可以实现去纹理而存边界</span></span><br><span class="line"> </span><br><span class="line">plt.subplot(<span class="number">321</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">322</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Averaging&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">323</span>),plt.imshow(blr),plt.title(<span class="string">&#x27;Bluring&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">324</span>),plt.imshow(g_blr),plt.title(<span class="string">&#x27;gaussian&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">325</span>),plt.imshow(m_blr),plt.title(<span class="string">&#x27;medianBlur&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">326</span>),plt.imshow(bi_blr),plt.title(<span class="string">&#x27;Bilaterial filtering&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h5 id="7-形态学操作"><a href="#7-形态学操作" class="headerlink" title="7. 形态学操作"></a>7. 形态学操作</h5><p>腐蚀：使用一个kernel扫过二值图片每一个角落，其下所有像素都1时候保留中心位置在原图对应的像素，否则被“腐蚀”为0</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erosion = cv.erode(img,kernel,iterations = <span class="number">1</span>) <span class="comment"># 腐蚀</span></span><br><span class="line">dilation = cv.dilate(img,kernel,iterations = <span class="number">1</span>) <span class="comment"># 膨胀：但凡kernel下面有个数值都将kernel中心位置像素设为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开运算 腐蚀后膨胀    可用于去噪</span></span><br><span class="line">opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 闭运算 膨胀后腐蚀    用于消除形状内部的小孔</span></span><br><span class="line">closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度 膨胀与腐蚀的差异 结果看起来像图形的外轮廓</span></span><br><span class="line">gradient = cv.morphologyEx(img, cv.MORPH_GRADIENT, kernel)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Top Hat 输入图像与开运算的差异</span></span><br><span class="line">tophat = cv.morphologyEx(img, cv.MORPH_TOPHAT, kernel)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Black Hat 输入图像与闭运算的差异</span></span><br><span class="line">blackhat = cv.morphologyEx(img, cv.MORPH_BLACKHAT, kernel)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>cv.getStructuringElement()</code>生成结构化kernel，输入形状和尺寸元组即可</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = cv.getStructuringElement(cv.MORPH_RECT,(<span class="number">5</span>,<span class="number">5</span>))  <span class="comment"># 矩形的</span></span><br><span class="line"><span class="built_in">print</span>(kernel)</span><br><span class="line">cv.getStructuringElement(cv.MORPH_ELLIPSE,(<span class="number">5</span>,<span class="number">5</span>))    <span class="comment"># 椭圆形的</span></span><br><span class="line">cv.getStructuringElement(cv.MORPH_CROSS,(<span class="number">5</span>,<span class="number">5</span>))  <span class="comment">#   十字形的</span></span><br></pre></td></tr></table></figure>
<h5 id="8-图像梯度"><a href="#8-图像梯度" class="headerlink" title="8. 图像梯度"></a>8. 图像梯度</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"> </span><br><span class="line">laplacian = cv.Laplacian(img,cv.CV_64F)</span><br><span class="line">sobelx = cv.Sobel(img,cv.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">5</span>)</span><br><span class="line">sobely = cv.Sobel(img,cv.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize=<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),plt.imshow(img,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Original&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),plt.imshow(laplacian,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Laplacian&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),plt.imshow(sobelx,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Sobel X&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>),plt.imshow(sobely,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Sobel Y&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>特别注意：将输出的数据类型设定高一些，如cv.CV_64F等，再转为cv.CV_8U，可避免丢失信息</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv.png&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Output dtype = cv.CV_8U</span></span><br><span class="line"><span class="comment">#sobelx8u = cv.Sobel(img,cv.CV_8U,1,0,ksize=3)</span></span><br><span class="line">sobelx8u = cv.Laplacian(img,cv.CV_8U)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Output dtype = cv.CV_64F. Then take its absolute and convert to cv.CV_8U</span></span><br><span class="line"><span class="comment">#sobelx64f = cv.Sobel(img,cv.CV_64F,1,0,ksize=3)</span></span><br><span class="line">sobelx64f = cv.Laplacian(img,cv.CV_64F)</span><br><span class="line">abs_sobel64f = np.absolute(sobelx64f)</span><br><span class="line">sobel_8u = np.uint8(abs_sobel64f)</span><br><span class="line"> </span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>),plt.imshow(img,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Original&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>),plt.imshow(sobelx8u,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Sobel CV_8U&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>),plt.imshow(sobel_8u,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Sobel abs(CV_64F)&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h5 id="9-图像金字塔"><a href="#9-图像金字塔" class="headerlink" title="9. 图像金字塔"></a>9. 图像金字塔</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lower_reso = cv.pyrDown(higher_reso)    <span class="comment"># 下取样</span></span><br><span class="line"></span><br><span class="line">higher_reso2 = cv.pyrUp(lower_reso)     <span class="comment"># 上取样</span></span><br></pre></td></tr></table></figure>
<p>使用金字塔操作混合两个图片的例子</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np,sys</span><br><span class="line"> </span><br><span class="line">A = cv.imread(<span class="string">&#x27;opencv.png&#x27;</span>)</span><br><span class="line">B = cv.imread(<span class="string">&#x27;opencv_white.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> A <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"><span class="keyword">assert</span> B <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># generate Gaussian pyramid for A</span></span><br><span class="line">G = A.copy()</span><br><span class="line">gpA = [G]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line"> G = cv.pyrDown(G)</span><br><span class="line"> gpA.append(G)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># generate Gaussian pyramid for B</span></span><br><span class="line">G = B.copy()</span><br><span class="line">gpB = [G]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line"> G = cv.pyrDown(G)</span><br><span class="line"> gpB.append(G)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># generate Laplacian Pyramid for A</span></span><br><span class="line">lpA = [gpA[<span class="number">5</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line"> GE = cv.pyrUp(gpA[i])</span><br><span class="line"> L = gpA[i-<span class="number">1</span>] - GE</span><br><span class="line"> lpA.append(L)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># generate Laplacian Pyramid for B</span></span><br><span class="line">lpB = [gpB[<span class="number">5</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line"> GE = cv.pyrUp(gpB[i])</span><br><span class="line"> L = gpB[i-<span class="number">1</span>] - GE</span><br><span class="line"> lpB.append(L)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Now add left and right halves of images in each level</span></span><br><span class="line">LS = []</span><br><span class="line"><span class="keyword">for</span> la,lb <span class="keyword">in</span> <span class="built_in">zip</span>(lpA,lpB):</span><br><span class="line"> rows,cols,dpt = la.shape</span><br><span class="line"> ls = np.hstack((la[:,<span class="number">0</span>:cols//<span class="number">2</span>], lb[:,cols//<span class="number">2</span>:]))</span><br><span class="line"> LS.append(ls)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># now reconstruct</span></span><br><span class="line">ls_ = LS[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line"> ls_ = cv.pyrUp(ls_)</span><br><span class="line"> ls_ = cv.add(ls_, LS[i])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># image with direct connecting each half</span></span><br><span class="line">real = np.hstack((A[:,:cols//<span class="number">2</span>],B[:,cols//<span class="number">2</span>:]))</span><br><span class="line"> </span><br><span class="line">cv.imshow(<span class="string">&#x27;Pyramid_blending2.jpg&#x27;</span>,ls_)</span><br><span class="line">cv.imshow(<span class="string">&#x27;Direct_blending.jpg&#x27;</span>,real)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h5 id="10-Canny-边缘检测"><a href="#10-Canny-边缘检测" class="headerlink" title="10. Canny 边缘检测"></a>10. Canny 边缘检测</h5><p>求梯度，边缘与梯度法线垂直，判断边缘点在梯度方向是否为局部最大值，是则保留，否则置零（非极大值抑制）；下一步，小于最小值不认为是边缘，大于最大值是确定边缘，位于其间而又与确定边缘相连的也予以保留，否则舍弃。<br>使用<code>cv.Canny()</code>，输入：图像，最小值，最大值，用于算梯度的Sobel kernel 尺寸（默认3），L2gradient(True 全面公式较精确，False 默认的简化公式)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">edges = cv.Canny(img,<span class="number">100</span>,<span class="number">180</span>)</span><br><span class="line"> </span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Original Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(edges,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Edge Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h5 id="11-轮廓检测"><a href="#11-轮廓检测" class="headerlink" title="11. 轮廓检测"></a>11. 轮廓检测</h5><p>使用<code>cv.findCountours()</code>获取轮廓，输入：源图，轮廓模式，近似方法<br>源图只能是二值图，白色为目标黑色为背景<br>近似方法用<code>cv.CHAIN_APPROX_NONE</code>将保存轮廓所有点，而用<code>cv.CHAIN_APPROX_SIMPLE</code>可以将轮廓用少量数据描述，如矩形仅用4个焦点等。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">contours, hierarchy = cv.findContours(thresh, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制Contours或者通过提供的边界点绘图</span></span><br><span class="line">cv.drawContours(im, contours, -<span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 输入：源图，轮廓，轮廓索引（-1全部），颜色，线宽</span></span><br><span class="line"></span><br><span class="line">cnt = countours[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">M = cv.moments(cnt) <span class="comment"># 求轮廓moments</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求轮廓质心</span></span><br><span class="line">c_x = M[<span class="string">&#x27;m10&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>]</span><br><span class="line">c_y = M[<span class="string">&#x27;m01&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>]</span><br><span class="line"></span><br><span class="line">area = cv.contourArea(cnt)  <span class="comment"># 求轮廓面积，即M[&#x27;m00&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求轮廓周长</span></span><br><span class="line">perimeter = cv.arcLength(cnt,<span class="literal">True</span>)  <span class="comment"># 输入：轮廓，轮廓是否闭合（True闭合）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 轮廓近似，根据指定的精度要求使用更少的顶点近似轮廓。</span></span><br><span class="line">epsilon = <span class="number">0.1</span>*cv.arcLength(cnt,<span class="literal">True</span>)    <span class="comment"># 精度参数：从轮廓到模拟轮廓的最大允许距离</span></span><br><span class="line">approx = cv.approxPolyDP(cnt,epsilon,<span class="literal">True</span>) </span><br></pre></td></tr></table></figure>
<p>凸包 Convex Hull<br>凸曲线都是往外凸的，只少也是平的。<code>cv.convexHull</code>用来修复凸性缺陷（内凹情况）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hull = cv.convexHull(points[, hull[, clockwise[, returnPoints]]])</span><br></pre></td></tr></table></figure>
<ul>
<li>points 传入的轮廓</li>
<li>hull 输出，通常免去</li>
<li>clockwise 方向标志 True顺时针</li>
<li>returnPoints 默认True返回凸点坐标，而False返回凸点坐标对应的轮廓点索引<br>实际使用<code>hull = cv.convexHull(cnt)</code>就行了</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(cv.isContourConvex(cnt))  <span class="comment"># 检查轮廓凸性</span></span><br></pre></td></tr></table></figure>

<p>轮廓的直边界框</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y, w, h = cv.boundingRect(cnt)</span><br><span class="line">cv.rectangle(im, (x,y),(x+w, y+h),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>轮廓的旋转边界宽<br>使用<code>cv.minAreaRect()</code>绘制轮廓的最小面积边界框，返回（中心坐标(x,y),(宽, 高)，旋转角度）。传入<code>cv.boxPoints()</code>绘制矩形</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rect = cv.minAreaRect(cnt)</span><br><span class="line">box = cv.boxPoints(rect)</span><br><span class="line">box = np.int0(box)</span><br><span class="line">cv.drawContours(im,[box],<span class="number">0</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>最小封闭圆<br>完全包括轮廓的最小圆</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(x,y),radius = cv.minEnclosingCircle(cnt)</span><br><span class="line">center = (<span class="built_in">int</span>(x),<span class="built_in">int</span>(y))</span><br><span class="line">radius = <span class="built_in">int</span>(radius)</span><br><span class="line">cv.circle(im,center,radius,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>拟合椭圆</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ellipse = cv.fitEllipse(cnt)</span><br><span class="line">cv.ellipse(im,ellipse,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>拟合直线</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows,cols = img.shape[:<span class="number">2</span>]</span><br><span class="line">[vx,vy,x,y] = cv.fitLine(cnt, cv.DIST_L2,<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0.01</span>)</span><br><span class="line">lefty = <span class="built_in">int</span>((-x*vy/vx) + y)</span><br><span class="line">righty = <span class="built_in">int</span>(((cols-x)*vy/vx)+y)</span><br><span class="line">cv.line(img,(cols-<span class="number">1</span>,righty),(<span class="number">0</span>,lefty),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h5 id="12-轮廓属性"><a href="#12-轮廓属性" class="headerlink" title="12. 轮廓属性"></a>12. 轮廓属性</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 宽高比 Aspect_ratio</span></span><br><span class="line">x,y,w,h = cv.boundingRect(cnt)</span><br><span class="line">aspect_ratio = <span class="built_in">float</span>(w)/h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 轮廓占边界框面积比 Extent</span></span><br><span class="line">area = cv.contourArea(cnt)</span><br><span class="line">x,y,w,h = cv.boundingRect(cnt)</span><br><span class="line">rect_area = w*h</span><br><span class="line">extent = <span class="built_in">float</span>(area)/rect_area</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坚固性 Solidity</span></span><br><span class="line">area = cv.contourArea(cnt)</span><br><span class="line">hull = cv.convexHull(cnt)</span><br><span class="line">hull_area = cv.contourArea(hull)</span><br><span class="line">solidity = <span class="built_in">float</span>(area)/hull_area</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当量直径 Equivalent Diameter 与轮廓面积相同圆的直径</span></span><br><span class="line">area = cv.contourArea(cnt)</span><br><span class="line">equi_diameter = np.sqrt(<span class="number">4</span>*area/np.pi)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方向 Orientation</span></span><br><span class="line">(x,y),(MA,ma),angle = cv.fitEllipse(cnt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mask</span></span><br><span class="line">mask = np.zeros(imgray.shape,np.uint8)</span><br><span class="line">cv.drawContours(mask,[cnt],<span class="number">0</span>,<span class="number">255</span>,-<span class="number">1</span>)</span><br><span class="line">pixelpoints = np.transpose(np.nonzero(mask))</span><br><span class="line"><span class="comment">#pixelpoints = cv.findNonZero(mask)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大值最小值及其位置</span></span><br><span class="line">min_val, max_val, min_loc, max_loc = cv.minMaxLoc(imgray,mask = mask)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平均颜色或亮度</span></span><br><span class="line">mean_val = cv.mean(im,mask = mask)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 极值点</span></span><br><span class="line">leftmost = <span class="built_in">tuple</span>(cnt[cnt[:,:,<span class="number">0</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">rightmost = <span class="built_in">tuple</span>(cnt[cnt[:,:,<span class="number">0</span>].argmax()][<span class="number">0</span>])</span><br><span class="line">topmost = <span class="built_in">tuple</span>(cnt[cnt[:,:,<span class="number">1</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">bottommost = <span class="built_in">tuple</span>(cnt[cnt[:,:,<span class="number">1</span>].argmax()][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多边形测试 返回点到多边形的最短距离，为正在轮廓内，为0在轮廓上，为负在轮廓外，第三参数True返回距离，False返回正负1（速度快2-3x）</span></span><br><span class="line">dist = cv.pointPolygonTest(cnt,(<span class="number">50</span>,<span class="number">50</span>),<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 轮廓匹配 可用于OCR</span></span><br><span class="line">ret, thresh = cv.threshold(img1, <span class="number">127</span>, <span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">ret, thresh2 = cv.threshold(img2, <span class="number">127</span>, <span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv.findContours(thresh,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">cnt1 = contours[<span class="number">0</span>]</span><br><span class="line">contours,hierarchy = cv.findContours(thresh2,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">cnt2 = contours[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line">ret = cv.matchShapes(cnt1,cnt2,<span class="number">1</span>,<span class="number">0.0</span>)</span><br><span class="line"><span class="built_in">print</span>( ret )</span><br></pre></td></tr></table></figure>

<h5 id="13-轮廓的层级"><a href="#13-轮廓的层级" class="headerlink" title="13. 轮廓的层级"></a>13. 轮廓的层级</h5><p>我们在使用查找轮廓的时候返回了一个hierarchy，即轮廓可能在另一轮廓之内的这种父子关系在opencv中的表达<br>** [Next, Previous, First_Child, Parent] **<br>Next 表示同一层级的下一个轮廓<br>Previous 同一层级的上一个轮廓<br>First_Child 第一个子轮廓<br>Parent 父轮廓</p>
<blockquote>
<p>注：如果没有父子轮廓，该位置设为-1</p>
</blockquote>
<p>轮廓检索模式<br><code>RETR_LIST</code>直接生成所有轮廓，无父子关系<br><code>RETR_EXTERNAL</code>只要最外轮廓<br><code>RETR_CCOMP</code> 排成2级，外部轮廓为层级1，孔洞轮廓为层级2<br><code>RETR_TREE</code> 完整的层级</p>
<h5 id="14-直方图"><a href="#14-直方图" class="headerlink" title="14. 直方图"></a>14. 直方图</h5><p>直方图的x轴是亮度，从0到255的（在8bit图像下，可以更改），纵高是每一亮度像素的总数量。直方图分析只用灰度图<br>直方图常用术语如下：<br><strong>BINS</strong> 用来指定x轴上有多少个区间，如256，或者16<br><strong>DIMS</strong> 采集数据的维度，如1<br><strong>RANGE</strong> 需要采集数据的范围，通常[0,256]</p>
<p>使用OpenCV获取直方图<br><code>cv.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]])</code></p>
<ol>
<li>images : uint8或float32的源图，用方括号包含，如 “[img]”。</li>
<li>channels : 准备计算的通道的索引，用方括号包含，灰度图可用[0]。彩色图可用[0], [1] 或 [2] 分别计算蓝色、绿色、红色通道的直方图。</li>
<li>mask : 掩膜图，计算全图直方图时候置”None”即可，否则创建一个mask放到这里。</li>
<li>histSize : 用方括号包含的<strong>BINS</strong>，如 [256]。</li>
<li>ranges : 范围，通常 [0,256]。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">hist = cv.calcHist([img],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">16</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用Numpy获取直方图，OpenCV比之快40x</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist,bins = np.histogram(img.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br></pre></td></tr></table></figure>
<p>绘制直方图</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;bottle.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">color = (<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i,col <span class="keyword">in</span> <span class="built_in">enumerate</span>(color):</span><br><span class="line">    histr = cv.calcHist([img],[i],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">    plt.plot(histr,color = col)</span><br><span class="line">    plt.xlim([<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>获取掩膜Mask内的直方图</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;bottle.png&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># create a mask</span></span><br><span class="line">mask = np.zeros(img.shape[:<span class="number">2</span>], np.uint8)</span><br><span class="line">mask[<span class="number">400</span>:<span class="number">800</span>, <span class="number">400</span>:<span class="number">1000</span>] = <span class="number">255</span></span><br><span class="line">masked_img = cv.bitwise_and(img,img,mask = mask)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Calculate histogram with mask and without mask</span></span><br><span class="line"><span class="comment"># Check third argument for mask</span></span><br><span class="line">hist_full = cv.calcHist([img],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">hist_mask = cv.calcHist([img],[<span class="number">0</span>],mask,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"> </span><br><span class="line">plt.subplot(<span class="number">221</span>), plt.imshow(img, <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>), plt.imshow(mask,<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>), plt.imshow(masked_img, <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>), plt.plot(hist_full), plt.plot(hist_mask)</span><br><span class="line">plt.xlim([<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>直方图均衡化，提高图像对比度，统一光照条件</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&#x27;wiki.jpg&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">equ = cv.equalizeHist(img)</span><br><span class="line">res = np.hstack((img,equ)) <span class="comment">#stacking images side-by-side</span></span><br><span class="line">cv.imwrite(<span class="string">&#x27;res.png&#x27;</span>,res)</span><br></pre></td></tr></table></figure>

<p>对比度有限自适应直方图均衡CLAHE<br>将图像分成小块做常规的直方图均衡，如果任何直方图bin超过了给定的对比度限（默认40），做直方图均衡前会将这些像素剪切均匀分散到其他bins，做完后使用双线性插值去除边界不自然。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create a CLAHE object (Arguments are optional).</span></span><br><span class="line">clahe = cv.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">cl1 = clahe.apply(img)</span><br><span class="line">cv.imwrite(<span class="string">&#x27;clahe_2.jpg&#x27;</span>,cl1)</span><br></pre></td></tr></table></figure>

<p>2D直方图<br>将图像BGR转HSV，对Hue和Saturation进行绘制，还是用<code>cv.calcHist()</code></p>
<ul>
<li>channels &#x3D; [0,1] 因为我们使用H 和 S 平面</li>
<li>bins &#x3D; [180,256] 180 是 H 平面，256是 S 平面</li>
<li>range &#x3D; [0,180,0,256] Hue范围从0到180，Saturation从0到256<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;view.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">hsv = cv.cvtColor(img,cv.COLOR_BGR2HSV)</span><br><span class="line">hist = cv.calcHist( [hsv], [<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>] )</span><br><span class="line"> </span><br><span class="line">plt.imshow(hist,interpolation = <span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>直方图反向投射<br>用于图像分割或者识别图像中物体。通过创建一个与输入同样宽高的单色图，其每个像素点代表输入图片的对应像素输入物体的概率，也就是越亮的地方有目标物体的概率越大。<br>方法：计算包含目标物体的图像之直方图，该图应经可能全部都是目标物体。做颜色直方图会比灰度直方图效果更佳。然后反向投射这个直方图到需要查找目标的图片，也就是计算目标图片每个像素属于目标物体图片的概率，并显示之。在合适的阈值下，可以达到将目标分割出来的目的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.calcBackProject(	images, channels, hist, ranges, scale[, dst]	) -&gt;	dst</span><br></pre></td></tr></table></figure>
<p>用法类似与<code>cv.calcHist()</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line">roi = cv.imread(<span class="string">&#x27;trees.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> roi <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">hsv = cv.cvtColor(roi,cv.COLOR_BGR2HSV)</span><br><span class="line"> </span><br><span class="line">target = cv.imread(<span class="string">&#x27;view.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> target <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">hsvt = cv.cvtColor(target,cv.COLOR_BGR2HSV)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># calculating object histogram</span></span><br><span class="line">roihist = cv.calcHist([hsv],[<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>] )</span><br><span class="line"> </span><br><span class="line"><span class="comment"># normalize histogram and apply backprojection</span></span><br><span class="line">cv.normalize(roihist,roihist,<span class="number">0</span>,<span class="number">255</span>,cv.NORM_MINMAX)</span><br><span class="line">dst = cv.calcBackProject([hsvt],[<span class="number">0</span>,<span class="number">1</span>],roihist,[<span class="number">0</span>,<span class="number">180</span>,<span class="number">0</span>,<span class="number">256</span>],<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Now convolute with circular disc</span></span><br><span class="line">disc = cv.getStructuringElement(cv.MORPH_ELLIPSE,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">cv.filter2D(dst,-<span class="number">1</span>,disc,dst)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># threshold and binary AND</span></span><br><span class="line">ret,thresh = cv.threshold(dst,<span class="number">50</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">thresh = cv.merge((thresh,thresh,thresh))</span><br><span class="line">res = cv.bitwise_and(target,thresh)</span><br><span class="line"> </span><br><span class="line">res = np.vstack((target,thresh,res))</span><br><span class="line">cv.imwrite(<span class="string">&#x27;res.jpg&#x27;</span>,res)</span><br></pre></td></tr></table></figure>
<h5 id="15-图像傅里叶转换"><a href="#15-图像傅里叶转换" class="headerlink" title="15. 图像傅里叶转换"></a>15. 图像傅里叶转换</h5><p>对应正弦信号，振幅剧烈变化表示高频，缓慢变化为低频。图像类似的，边缘和噪音的亮度变化剧烈，因此算是高频信号。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">&#x27;view.jpg&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">f = np.fft.fft2(img)    <span class="comment"># 变换</span></span><br><span class="line">fshift = np.fft.fftshift(f) <span class="comment"># 将低频放到中心</span></span><br><span class="line">magnitude_spectrum = <span class="number">20</span>*np.log(np.<span class="built_in">abs</span>(fshift))</span><br><span class="line"> </span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img, cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(magnitude_spectrum, cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Magnitude Spectrum&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">rows, cols = img.shape</span><br><span class="line">crow, ccol = rows//<span class="number">2</span>, cols//<span class="number">2</span></span><br><span class="line">fshift[crow-<span class="number">10</span>:crow+<span class="number">11</span>, ccol-<span class="number">10</span>:ccol+<span class="number">11</span>] = <span class="number">0</span>    <span class="comment"># 低频删除</span></span><br><span class="line">f_ishift = np.fft.ifftshift(fshift) <span class="comment"># 逆偏移</span></span><br><span class="line">img_back = np.fft.ifft2(f_ishift)   <span class="comment"># 逆变换</span></span><br><span class="line">img_back = np.real(img_back)</span><br><span class="line"> </span><br><span class="line">plt.subplot(<span class="number">131</span>),plt.imshow(img, cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">132</span>),plt.imshow(img_back, cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Image after HPF&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">133</span>),plt.imshow(img_back)</span><br><span class="line">plt.title(<span class="string">&#x27;Result in JET&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>OpenCV的实现要快一些，但是没有Numpy这么直观。</p>
<h5 id="16-模板匹配"><a href="#16-模板匹配" class="headerlink" title="16. 模板匹配"></a>16. 模板匹配</h5><p>使用<code>cv.matchTemplate() </code>，如果输入图像尺寸（W,H），目标图(w,h)，那么输出(W-h+1,H-h+1)<br>使用<code>cv.minMaxLoc()</code>找到极值之所在作为矩形左上角坐标，结合（w，h）绘制包含目标的矩形</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;view.jpg&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">img2 = img.copy()</span><br><span class="line">template = cv.imread(<span class="string">&#x27;build.jpg&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> template <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">w, h = template.shape[::-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># All the 6 methods for comparison in a list</span></span><br><span class="line">methods = [<span class="string">&#x27;cv.TM_CCOEFF&#x27;</span>, <span class="string">&#x27;cv.TM_CCOEFF_NORMED&#x27;</span>, <span class="string">&#x27;cv.TM_CCORR&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;cv.TM_CCORR_NORMED&#x27;</span>, <span class="string">&#x27;cv.TM_SQDIFF&#x27;</span>, <span class="string">&#x27;cv.TM_SQDIFF_NORMED&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> meth <span class="keyword">in</span> methods:</span><br><span class="line">    img = img2.copy()</span><br><span class="line">    method = <span class="built_in">eval</span>(meth)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Apply template Matching</span></span><br><span class="line">    res = cv.matchTemplate(img,template,method)</span><br><span class="line">    min_val, max_val, min_loc, max_loc = cv.minMaxLoc(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If the method is TM_SQDIFF or TM_SQDIFF_NORMED, take minimum</span></span><br><span class="line">    <span class="keyword">if</span> method <span class="keyword">in</span> [cv.TM_SQDIFF, cv.TM_SQDIFF_NORMED]:</span><br><span class="line">        top_left = min_loc</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        top_left = max_loc</span><br><span class="line">        bottom_right = (top_left[<span class="number">0</span>] + w, top_left[<span class="number">1</span>] + h)</span><br><span class="line"></span><br><span class="line">    cv.rectangle(img,top_left, bottom_right, <span class="number">255</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">121</span>),plt.imshow(res,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Matching Result&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">122</span>),plt.imshow(img,cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Detected Point&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.suptitle(meth)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<h5 id="17-霍夫直线变换"><a href="#17-霍夫直线变换" class="headerlink" title="17. 霍夫直线变换"></a>17. 霍夫直线变换</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;img loading wrong&quot;</span></span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">edges = cv.Canny(gray,<span class="number">50</span>,<span class="number">150</span>,apertureSize = <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入： 二值图，ρ精度，θ精度，阈值</span></span><br><span class="line">lines = cv.HoughLines(edges,<span class="number">1</span>,np.pi/<span class="number">180</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line"> rho,theta = line[<span class="number">0</span>]</span><br><span class="line"> a = np.cos(theta)</span><br><span class="line"> b = np.sin(theta)</span><br><span class="line"> x0 = a*rho</span><br><span class="line"> y0 = b*rho</span><br><span class="line"> x1 = <span class="built_in">int</span>(x0 + <span class="number">1000</span>*(-b))</span><br><span class="line"> y1 = <span class="built_in">int</span>(y0 + <span class="number">1000</span>*(a))</span><br><span class="line"> x2 = <span class="built_in">int</span>(x0 - <span class="number">1000</span>*(-b))</span><br><span class="line"> y2 = <span class="built_in">int</span>(y0 - <span class="number">1000</span>*(a))</span><br><span class="line"> </span><br><span class="line"> cv.line(img,(x1,y1),(x2,y2),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">cv.imwrite(<span class="string">&#x27;houghlines3.jpg&#x27;</span>,img)</span><br></pre></td></tr></table></figure>
<p>霍夫圆变换</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv_white.png&#x27;</span>, cv.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line">img = cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">cimg = cv.cvtColor(img,cv.COLOR_GRAY2BGR)</span><br><span class="line"> </span><br><span class="line">circles = cv.HoughCircles(img,cv.HOUGH_GRADIENT,<span class="number">1</span>,<span class="number">20</span>,</span><br><span class="line"> param1=<span class="number">50</span>,param2=<span class="number">30</span>,minRadius=<span class="number">0</span>,maxRadius=<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">circles = np.uint16(np.around(circles))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> circles[<span class="number">0</span>,:]:</span><br><span class="line"> <span class="comment"># draw the outer circle</span></span><br><span class="line"> cv.circle(cimg,(i[<span class="number">0</span>],i[<span class="number">1</span>]),i[<span class="number">2</span>],(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line"> <span class="comment"># draw the center of the circle</span></span><br><span class="line"> cv.circle(cimg,(i[<span class="number">0</span>],i[<span class="number">1</span>]),<span class="number">2</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">cv.imshow(<span class="string">&#x27;detected circles&#x27;</span>,cimg)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://debugtheuniverse.github.io/2024/03/20/OpenCV%20%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" data-id="cltzuur5n0001mcuk7dabhpeq" data-title="OpenCV 图像处理" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OpenCV 快速使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/20/OpenCV%20%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2024-03-19T16:06:12.810Z" itemprop="datePublished">2024-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/20/OpenCV%20%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/">OpenCV 快速使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="1-安装opencv"><a href="#1-安装opencv" class="headerlink" title="1. 安装opencv"></a>1. 安装opencv</h5><p>在windows系统中，打开cmd窗口，输入如下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-contrib-python -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<p>使用contrib版本的功能要全面一些，后面的-i及其后是使用清华的源进行下载，会快很多。</p>
<p>检查是否安装成功</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="built_in">print</span>(cv.__version__)   <span class="comment"># 正常则显示版本号，我的例子是&#x27;4.9.0&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-基础绘制功能"><a href="#2-基础绘制功能" class="headerlink" title="2. 基础绘制功能"></a>2. 基础绘制功能</h5><p><code>cv.line(), cv.circle() , cv.rectangle(), cv.ellipse(), cv.putText()</code>分别用来在图片上绘制直线、圆形、矩形、椭圆、添加文字。他们的参数非常类似，都包含如下几个</p>
<ul>
<li>img: 绘制图形的目标图片</li>
<li>color: 绘制什么颜色的图形</li>
<li>thickness: 线条的粗细</li>
<li>lineType: 线型 （没发现区别）</li>
</ul>
<p>举个例子</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个黑色图片</span></span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 画一条蓝色对角线，注意颜色排序是BGR，所以（255，0，0）是蓝色</span></span><br><span class="line">cv.line(img,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">500</span>,<span class="number">500</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画矩形</span></span><br><span class="line">cv.rectangle(img, (<span class="number">200</span>, <span class="number">200</span>), (<span class="number">280</span>, <span class="number">300</span>), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 圆，指定圆心坐标（300，100），半径100，颜色.., 线宽2</span></span><br><span class="line">cv.circle(img, (<span class="number">300</span>, <span class="number">100</span>), <span class="number">100</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#椭圆：图像，椭圆中心，（长轴长度，短轴长度），角度，弧起角度，弧结束角度，（B, G, R), 线宽</span></span><br><span class="line">cv.ellipse(img, (<span class="number">100</span>, <span class="number">300</span>), (<span class="number">50</span>, <span class="number">30</span>), <span class="number">60</span>, <span class="number">0</span>, <span class="number">360</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pts = np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]], np.int32)</span><br><span class="line">pts = pts.reshape((-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制多段线，第三个isClosed 如果设为True，可以自动将多段线闭合成多边形</span></span><br><span class="line">cv.polylines(img, [pts], <span class="literal">False</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文字</span></span><br><span class="line">font = cv.FONT_HERSHEY_COMPLEX</span><br><span class="line">cv.putText(img, <span class="string">&#x27;hello world&#x27;</span>, (<span class="number">40</span>, <span class="number">460</span>),font, <span class="number">1</span>, (<span class="number">0x11</span>,<span class="number">0xaa</span>,<span class="number">0x11</span>),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;draw&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="3-用鼠标绘制"><a href="#3-用鼠标绘制" class="headerlink" title="3. 用鼠标绘制"></a>3. 用鼠标绘制</h5><p>鼠标点击左键，绘制圆形。其中使用到了<code>cv.setMouseCallback</code>来为图像设置回调函数，回调函数<code>draw_cicle</code>接收<code>event</code>以及事件发生时的xy坐标，函数内判断事件类型，进行处理。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line"><span class="comment"># mouse callback function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_circle</span>(<span class="params">event,x,y,flags,param</span>):</span><br><span class="line">    <span class="keyword">if</span> event == cv.EVENT_LBUTTONDOWN:</span><br><span class="line">        cv.circle(img,(x,y),<span class="number">100</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create a black image, a window and bind the function to window</span></span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">cv.setMouseCallback(<span class="string">&#x27;image&#x27;</span>,draw_circle)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">&#x27;image&#x27;</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">20</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>更高级的例子，使用m键切换模式，鼠标点击后拖动绘制矩形和圆形。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line">drawing = <span class="literal">False</span> <span class="comment"># true if mouse is pressed</span></span><br><span class="line">mode = <span class="literal">True</span> <span class="comment"># if True, draw rectangle. Press &#x27;m&#x27; to toggle to curve</span></span><br><span class="line">ix,iy = -<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># mouse callback function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_circle</span>(<span class="params">event,x,y,flags,param</span>):</span><br><span class="line">    <span class="keyword">global</span> ix,iy,drawing,mode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> event == cv.EVENT_LBUTTONDOWN:</span><br><span class="line">        drawing = <span class="literal">True</span></span><br><span class="line">        ix,iy = x,y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> event == cv.EVENT_MOUSEMOVE:</span><br><span class="line">        <span class="keyword">if</span> drawing == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="literal">True</span>:</span><br><span class="line">                cv.rectangle(img,(ix,iy),(x,y),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cv.circle(img,(ix,iy),<span class="built_in">int</span>(<span class="built_in">abs</span>(math.sqrt((x-ix)**<span class="number">2</span>+(y-iy)**<span class="number">2</span>))),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> event == cv.EVENT_LBUTTONUP:</span><br><span class="line">        drawing = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment">#cv.rectangle(img,(ix,iy),(x,y),(0,255,0),-1)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment">#cv.circle(img,(x,y),5,(0,0,255),-1)</span></span><br><span class="line"></span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">cv.setMouseCallback(<span class="string">&#x27;image&#x27;</span>,draw_circle)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">&#x27;image&#x27;</span>,img)</span><br><span class="line">    k = cv.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&#x27;m&#x27;</span>):</span><br><span class="line">        mode = <span class="keyword">not</span> mode</span><br><span class="line">    <span class="keyword">elif</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="4-TrackBar使用"><a href="#4-TrackBar使用" class="headerlink" title="4. TrackBar使用"></a>4. TrackBar使用</h5><p>使用<code>cv.createTrackBar()</code>创建控制条，输入参数为：控制条名称、窗口名称、初始值、最大值、回调函数<br>使用<code>cv.getTrackBarPos()</code>获取控制条当前位置，输入参数：控制条名称、窗口名称<br>OpenCV里面没有按钮，因此可以创建一个最大值为1的控制条，作为开关使用</p>
<p>举个例子，带有开关的调色板</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create a black image, a window</span></span><br><span class="line">img = np.zeros((<span class="number">300</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># create trackbars for color change</span></span><br><span class="line">cv.createTrackbar(<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;image&#x27;</span>,<span class="number">128</span>,<span class="number">255</span>,nothing)</span><br><span class="line"> </span><br><span class="line">cv.createTrackbar(<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;image&#x27;</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv.createTrackbar(<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;image&#x27;</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># create switch for ON/OFF functionality</span></span><br><span class="line">switch = <span class="string">&#x27;0 : OFF \n1 : ON&#x27;</span></span><br><span class="line">cv.createTrackbar(switch, <span class="string">&#x27;image&#x27;</span>,<span class="number">0</span>,<span class="number">1</span>,nothing)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">&#x27;image&#x27;</span>,img)</span><br><span class="line">    k = cv.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get current positions of four trackbars</span></span><br><span class="line">    r = cv.getTrackbarPos(<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    g = cv.getTrackbarPos(<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    b = cv.getTrackbarPos(<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    s = cv.getTrackbarPos(switch,<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">        img[:] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        img[:] = [b,g,r]</span><br><span class="line"> </span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>更复杂一些的例子，使用控制条改变绘制的颜色画笔尺寸</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line">drawing = <span class="literal">False</span> <span class="comment"># true if mouse is pressed</span></span><br><span class="line">mode = <span class="literal">True</span> <span class="comment"># if True, draw rectangle. Press &#x27;m&#x27; to toggle to curve</span></span><br><span class="line">ix,iy = -<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># mouse callback function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_circle</span>(<span class="params">event,x,y,flags,param</span>):</span><br><span class="line">    <span class="keyword">global</span> ix,iy,drawing,mode</span><br><span class="line">    r = cv.getTrackbarPos(<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    g = cv.getTrackbarPos(<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    b = cv.getTrackbarPos(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    b_size = cv.getTrackbarPos(<span class="string">&#x27;brush_size&#x27;</span>,<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> event == cv.EVENT_LBUTTONDOWN:</span><br><span class="line">        drawing = <span class="literal">True</span></span><br><span class="line">        ix,iy = x,y</span><br><span class="line">        <span class="keyword">if</span> mode == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cv.circle(img,(x,y),b_size,(b,g,r),-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> event == cv.EVENT_MOUSEMOVE:</span><br><span class="line">        <span class="keyword">if</span> drawing == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="literal">True</span>:</span><br><span class="line">                cv.rectangle(img,(ix,iy),(x,y),(b,g,r),-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cv.circle(img,(ix,iy),<span class="built_in">int</span>(<span class="built_in">abs</span>(math.sqrt((x-ix)**<span class="number">2</span>+(y-iy)**<span class="number">2</span>))),(b,g,r),-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> event == cv.EVENT_LBUTTONUP:</span><br><span class="line">        drawing = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment">#cv.rectangle(img,(ix,iy),(x,y),(0,255,0),-1)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment">#cv.circle(img,(x,y),5,(0,0,255),-1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">cv.setMouseCallback(<span class="string">&#x27;image&#x27;</span>,draw_circle)</span><br><span class="line"></span><br><span class="line">cv.createTrackbar(<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;image&#x27;</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv.createTrackbar(<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;image&#x27;</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv.createTrackbar(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;image&#x27;</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv.createTrackbar(<span class="string">&#x27;brush_size&#x27;</span>, <span class="string">&#x27;image&#x27;</span>, <span class="number">0</span>, <span class="number">100</span>, nothing)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">&#x27;image&#x27;</span>,img)</span><br><span class="line">    k = cv.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&#x27;m&#x27;</span>):</span><br><span class="line">        mode = <span class="keyword">not</span> mode</span><br><span class="line">    <span class="keyword">elif</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5-像素-通道-边框操作"><a href="#5-像素-通道-边框操作" class="headerlink" title="5. 像素&#x2F;通道&#x2F;边框操作"></a>5. 像素&#x2F;通道&#x2F;边框操作</h5><ul>
<li>单像素操作首选<code>array.item()</code>和<code>array.itemset()</code></li>
<li>通道操作直接用numpy切片选择</li>
<li>roi不是复制，是view，因此roi的修改会改变原图数据</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">&#x27;bottle.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, checks with os.path.exists()&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引某个像素点</span></span><br><span class="line">px = img[<span class="number">100</span>,<span class="number">100</span>]</span><br><span class="line"><span class="built_in">print</span>(px)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引某个像素点的蓝色值</span></span><br><span class="line">px_blue = img[<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(px_blue)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改某个像素点的数值</span></span><br><span class="line">img[<span class="number">100</span>,<span class="number">100</span>] = [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上使用Numpy的array.item()和array.itemset()做以上操作会更好</span></span><br><span class="line"><span class="built_in">print</span>(img.item(<span class="number">50</span>,<span class="number">50</span>,<span class="number">0</span>))</span><br><span class="line">img.itemset((<span class="number">50</span>,<span class="number">50</span>,<span class="number">2</span>),<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取图像尺寸，可以通过有无通道数判断是否彩色，返回tuple （高，宽，通道数）</span></span><br><span class="line"><span class="built_in">print</span>(img.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取图像大小，即以上尺寸的乘积</span></span><br><span class="line"><span class="built_in">print</span>(img.size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像的数据类型，有很多错误就是由于数据类型不匹配造成的</span></span><br><span class="line"><span class="built_in">print</span>(img.dtype)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ROI选择，将一个区域移动到另外一个区域</span></span><br><span class="line">obj = img[<span class="number">280</span>:<span class="number">340</span>, <span class="number">330</span>:<span class="number">390</span>]</span><br><span class="line">obj[:,:,:] = <span class="number">0</span> <span class="comment"># obj是numpy的一个选择，没有copy，修改之会影响img</span></span><br><span class="line">img[<span class="number">273</span>:<span class="number">333</span>, <span class="number">100</span>:<span class="number">160</span>] = obj</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将彩色图像按通道拆分、组合</span></span><br><span class="line">b, g, r = cv.split(img)</span><br><span class="line">img = cv.merge((b,g,r))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意cv.split耗时，不如使用numpy切片实现</span></span><br><span class="line">img[:,:,<span class="number">2</span>] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给图片加边，这在卷积模型中常用到，使用cv.copyMakeBorder(),输入：目标图、上、下、左、右宽、类型、颜色（常量类型）</span></span><br><span class="line"><span class="comment"># 类型分为：</span></span><br><span class="line"><span class="comment"># cv.BORDER_CONSTANT常量填充</span></span><br><span class="line"><span class="comment"># cv.BORDER_REFLECT镜像填充如：fedcba|abcdefgh|hgfedcb</span></span><br><span class="line"><span class="comment"># cv.BORDER_REFLECT_101镜像填充如：fedcb|abcdefgh|gfedcb</span></span><br><span class="line"><span class="comment"># cv.BORDER_REPLICATE最后元素重复如：aaaaaa|abcdefgh|hhhhhhh</span></span><br><span class="line"><span class="comment"># cv.BORDER_WRAP头尾相接填充如：cdefgh|abcdefgh|abcdefg</span></span><br><span class="line">img = cv.copyMakeBorder(img,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,cv.BORDER_WRAP)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv.namedWindow(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;image&#x27;</span>,img)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="6-图像相加与混合"><a href="#6-图像相加与混合" class="headerlink" title="6. 图像相加与混合"></a>6. 图像相加与混合</h5><p>与普通相加的区别，使用<code>cv.add()</code>相加结果大于数据类型范围会设为最大值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">x = np.array(<span class="number">250</span>, dtype=np.uint8)</span><br><span class="line">y = np.array(<span class="number">10</span>, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cv.add(x,y)) <span class="comment"># x + y = 260 &gt; 255(uint8) 因此 [[255]]</span></span><br><span class="line"><span class="built_in">print</span>(x+y)  <span class="comment"># 260 % 256 = 4 因此 4</span></span><br></pre></td></tr></table></figure>

<p>使用<code>cv.addWighted()</code>将两个图片混合起来，</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">img1 = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">&#x27;opencv.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"><span class="keyword">assert</span> img2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  输入 图像1，系数1，图像2， 系数2，γ</span></span><br><span class="line"><span class="comment"># 系数1 + 系数2 = 1</span></span><br><span class="line"><span class="comment"># γ是添加到每个像素的标量</span></span><br><span class="line">dst = cv.addWeighted(img1,<span class="number">0.6</span>,img2,<span class="number">0.4</span>,<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">cv.imshow(<span class="string">&#x27;dst&#x27;</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>按位操作 Bitwise Operations<br>以下是实现将一个logo扣出来贴到另一个图片的例子</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读两张图片</span></span><br><span class="line">img1 = cv.imread(<span class="string">&#x27;bottle.png&#x27;</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">&#x27;opencv.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"><span class="keyword">assert</span> img2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 准备让logo出现在图片的左上，所以创建一个ROI</span></span><br><span class="line">rows,cols,channels = img2.shape</span><br><span class="line">roi = img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 做一个logo的mask，及非logo区域的mask</span></span><br><span class="line">img2gray = cv.cvtColor(img2,cv.COLOR_BGR2GRAY)</span><br><span class="line">ret, mask = cv.threshold(img2gray, <span class="number">10</span>, <span class="number">255</span>, cv.THRESH_BINARY)</span><br><span class="line">mask_inv = cv.bitwise_not(mask) <span class="comment"># 按位非操作实现非logo区域mask</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将ROI中logo的图像去掉</span></span><br><span class="line">img1_bg = cv.bitwise_and(roi,roi,mask = mask_inv)</span><br><span class="line">cv.imshow(<span class="string">&#x27;img1_bg&#x27;</span>,img1_bg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从logo图片中只提取logo的部分</span></span><br><span class="line">img2_fg = cv.bitwise_and(img2,img2,mask = mask)</span><br><span class="line">cv.imshow(<span class="string">&#x27;img2_fg&#x27;</span>,img2_fg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将提取的logo图形与已经去掉图形的背景图相加</span></span><br><span class="line">dst = cv.add(img1_bg,img2_fg)</span><br><span class="line">img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols ] = dst</span><br><span class="line"> </span><br><span class="line">cv.imshow(<span class="string">&#x27;res&#x27;</span>,img1)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="7-性能检查与优化"><a href="#7-性能检查与优化" class="headerlink" title="7. 性能检查与优化"></a>7. 性能检查与优化</h5><p>使用<code>cv.getTickCount()</code>获取时钟周期，在要判断耗时的程序前后各获取一次，求差<br>使用<code>cv.getTickFrequency()</code>获取时钟频率，耗时（秒） &#x3D; 周期数量 &#x2F; 频率</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">e1 = cv.getTickCount()  <span class="comment"># 使用time也是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;do something&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e2 = cv.getTickCount()</span><br><span class="line">t = (e2 - e1) / cv.getTickFrequency()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure>

<p>性能优化</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment">#cv.setUseOptimized(False)  # 默认开了优化，可以手动开关</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>)</span><br><span class="line">e1 = cv.getTickCount()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">49</span>, <span class="number">2</span>):</span><br><span class="line">    img1 = cv.medianBlur(img, i)</span><br><span class="line">e2 = cv.getTickCount()</span><br><span class="line">t = (e2 - e1) / cv.getTickFrequency()</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"><span class="built_in">print</span>(cv.useOptimized())</span><br></pre></td></tr></table></figure>

<p>使用<code>IPython</code>时可以用它的命令<code>%timeit</code>非常方便地对每行代码用时进行分析<br>创建数组、单个或两个元素运算时，python直接运算以及opencv算法都比numpy快</p>
<p>性能优化方面的思路：首先以简单的方式实现算法，一旦算法开始工作，分析找到其瓶颈优化之</p>
<ol>
<li>尽可能避免在Python中使用循环</li>
<li>最大可能地将算法向量化，因为numpy和opencv都针对向量运算进行了优化</li>
<li>非必要不复制<code>array</code>，只使用其<code>views</code><br>如果代码还是慢，考虑用Cython</li>
</ol>
<p>附加资源</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips">Python Optimization Techniques</a></li>
<li><a target="_blank" rel="noopener" href="http://scipy-lectures.github.io/advanced/advanced_numpy/index.html#advanced-numpy">Scipy Lecture Notes - Advanced Numpy</a></li>
<li><a target="_blank" rel="noopener" href="http://pynash.org/2013/03/06/timing-and-profiling/">Timing and Profiling in IPython</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://debugtheuniverse.github.io/2024/03/20/OpenCV%20%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/" data-id="cltyl7mrj0000uouk2kd75vha" data-title="OpenCV 快速使用" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OpenCV VideoWriter" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/19/OpenCV%20VideoWriter/" class="article-date">
  <time class="dt-published" datetime="2024-03-19T09:12:17.069Z" itemprop="datePublished">2024-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/19/OpenCV%20VideoWriter/">OpenCV VideoWriter</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>Windows 11<br>python 3.12.2<br>opencv-contrib-python 4.9.0.80</p>
<h4 id="保存视频问题"><a href="#保存视频问题" class="headerlink" title="保存视频问题"></a>保存视频问题</h4><p>使用<code>VideoWriter</code>保存视频的时候结果只有1kb，显示文件已损坏。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建采集object</span></span><br><span class="line">cap = cv.VideoCapture(<span class="string">&#x27;video.mp4&#x27;</span>) <span class="comment"># 传入-1默认摄像头，也可是摄像头序号0/1/2，或视频文件名称</span></span><br><span class="line"></span><br><span class="line">frame_height = cap.get(<span class="number">3</span>)</span><br><span class="line">frame_width = cap.get(<span class="number">4</span>)</span><br><span class="line">size = (frame_width, frame_height)  <span class="comment"># 使用VideoWriter时输出必须与输入同尺寸</span></span><br><span class="line"></span><br><span class="line">writer = cv2.VideoWriter(<span class="string">&#x27;out.mov&#x27;</span>, cv2.VideoWriter_fourcc(*<span class="string">&#x27;divx&#x27;</span>), <span class="number">25.5</span>, size, isColor=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 输出格式亲测.avi .mov .mp4可用</span></span><br><span class="line"><span class="comment"># fourcc参数divx和mp4v都可用</span></span><br><span class="line"><span class="comment"># 帧率可以是浮点数</span></span><br><span class="line"><span class="comment"># 尺寸是个与源视频同样大小的元组则可用，顺序为（宽，高）</span></span><br><span class="line"><span class="comment"># 如果对图像进行了灰度处理，必须修改isColor为False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;can\&#x27;t recieve frame, exiting...&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span></span><br><span class="line">    out.write(frame)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://debugtheuniverse.github.io/2024/03/19/OpenCV%20VideoWriter/" data-id="clty6czx000008cukehluh2a1" data-title="OpenCV VideoWriter" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pyautogui" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/14/pyautogui/" class="article-date">
  <time class="dt-published" datetime="2024-03-13T16:03:46.394Z" itemprop="datePublished">2024-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/14/pyautogui/">pyautogui</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>pyautogui可以控制鼠标移动和点击，可以用来实现一些自动化的操作，非常有趣。</p>
<h4 id="先看注意事项"><a href="#先看注意事项" class="headerlink" title="先看注意事项"></a>先看注意事项</h4><p>为避免失控，快速甩动鼠标到屏幕角落以强行退出程序。</p>
<h4 id="一、控制鼠标"><a href="#一、控制鼠标" class="headerlink" title="一、控制鼠标"></a>一、控制鼠标</h4><h5 id="1-安装pyautogui"><a href="#1-安装pyautogui" class="headerlink" title="1. 安装pyautogui"></a>1. 安装pyautogui</h5><p>在Windows的cmd窗口输入指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyautogui</span><br></pre></td></tr></table></figure>

<h5 id="2-确认安装正常"><a href="#2-确认安装正常" class="headerlink" title="2. 确认安装正常"></a>2. 确认安装正常</h5><p>使用<code>pyautogui.size()</code>获取当前屏幕的宽高，返回是一个点对象。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line">wh = pyautogui.size()</span><br><span class="line"><span class="built_in">print</span>(wh.width, wh.height)</span><br></pre></td></tr></table></figure>

<h5 id="3-移动鼠标到绝对位置"><a href="#3-移动鼠标到绝对位置" class="headerlink" title="3. 移动鼠标到绝对位置"></a>3. 移动鼠标到绝对位置</h5><p>使用<code>pyautogui.moveTo()</code>可将光标移至屏幕任意位置，传入三个参数，前两个分别为位置坐标<code>x</code>与<code>y</code>，第三个<code>duration=</code>用来指定这个动作的耗时。<br>先了解一下计算机显示器的像素坐标系，屏幕左上为原点，x轴指向右侧，y轴指向屏幕底端。</p>
<center>
<img src="./assets/img/coordinate-system-of-screen.png" width="30%" height="30%">
图1 分辨率为1920x1080的屏幕坐标系图片<sup>[1]<sup>
</center>


<p>举个例子，让鼠标自动画长方形。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    pyautogui.moveTo(<span class="number">100</span>, <span class="number">100</span>, duration=<span class="number">0.25</span>)</span><br><span class="line">    pyautogui.moveTo(<span class="number">100</span>, <span class="number">400</span>, duration=<span class="number">0.25</span>)</span><br><span class="line">    pyautogui.moveTo(<span class="number">400</span>, <span class="number">400</span>, duration=<span class="number">0.25</span>)</span><br><span class="line">    pyautogui.moveTo(<span class="number">400</span>, <span class="number">100</span>, duration=<span class="number">0.25</span>)</span><br></pre></td></tr></table></figure>

<h5 id="4-移动鼠标到相对位置"><a href="#4-移动鼠标到相对位置" class="headerlink" title="4. 移动鼠标到相对位置"></a>4. 移动鼠标到相对位置</h5><p>使用<code>pyautogui.move()</code>，同样是三个参数，区别是坐标为相对位移坐标。<br>如果要获得鼠标当前位于何处，可以使用<code>pyautogui.positioin()</code>，没有参数，返回一个对象包含两个坐标值。</p>
<h5 id="5-控制鼠标点击"><a href="#5-控制鼠标点击" class="headerlink" title="5. 控制鼠标点击"></a>5. 控制鼠标点击</h5><p>让鼠标在坐标（100，100）处完成一次左键单击，使用<code>pyautogui.click()</code>，传入的第三个参数<code>button=</code>用来指定左键、中键和右键。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line">pyautogui.click(<span class="number">100</span>, <span class="number">100</span>, button=<span class="string">&#x27;left&#x27;</span>)    <span class="comment"># 点击左键</span></span><br><span class="line">pytutogui.click(<span class="number">100</span>, <span class="number">100</span>, button=<span class="string">&#x27;right&#x27;</span>)   <span class="comment"># 点击右键</span></span><br></pre></td></tr></table></figure>
<p>完成一次点击包括两个动作，也就是按下与释放。<code>pyautogui.click()</code>使用了默认的时间间隔。如果我们想要自定义按下和释放之间的保持时间，就使用<code>pyautogui.mouseDown()</code>来按下，用<code>pyautogui.mouseUp()</code>来释放，参数相同。</p>
<h5 id="6-拖动鼠标"><a href="#6-拖动鼠标" class="headerlink" title="6. 拖动鼠标"></a>6. 拖动鼠标</h5><p>按下后保持，再移动鼠标，可用<code>pyautogui.dragTo()</code>或者<code>pyautogui.drag()</code>实现，前者是绝对位置，后者为相对位置。<br>以下代码是用鼠标绘图的例子</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>)   <span class="comment"># 等待切换软件窗口</span></span><br><span class="line">pyautogui.click(<span class="number">800</span>, <span class="number">600</span>)   <span class="comment"># 点击画幅内的一点作为起点</span></span><br><span class="line"></span><br><span class="line">distance = <span class="number">500</span></span><br><span class="line">change = <span class="number">20</span></span><br><span class="line"><span class="keyword">while</span> distance &gt; <span class="number">0</span>:</span><br><span class="line">    pyautogui.drag(distance, <span class="number">0</span>, duration=<span class="number">0.2</span>)   <span class="comment"># Move right.</span></span><br><span class="line">    distance = distance - change</span><br><span class="line">    pyautogui.drag(<span class="number">0</span>, distance, duration=<span class="number">0.2</span>)   <span class="comment"># Move down.</span></span><br><span class="line">    pyautogui.drag(-distance, <span class="number">0</span>, duration=<span class="number">0.2</span>)  <span class="comment"># Move left.</span></span><br><span class="line">    distance = distance - change</span><br><span class="line">    pyautogui.drag(<span class="number">0</span>, -distance, duration=<span class="number">0.2</span>) </span><br></pre></td></tr></table></figure>
<p>事先打开一个绘图软件，此处以windows绘图软件为例，选择好画笔后回到IDE启动脚本。程序中有一个5s的延时，因此启动程序后5s内将实现准备好的绘图软件窗口最大化。</p>
<center>
<img src="./assets/img/drag-painting.png" width="60%" height="60%">
图2 pyautogui.drag()拖动鼠标绘制图形的结果
</center>

<h5 id="7-控制滚轮"><a href="#7-控制滚轮" class="headerlink" title="7. 控制滚轮"></a>7. 控制滚轮</h5><p>使用<code>pyautogui.scroll()</code>输入参数为整数滚动单位。</p>
<h5 id="8-获取屏幕上某一点的像素坐标"><a href="#8-获取屏幕上某一点的像素坐标" class="headerlink" title="8. 获取屏幕上某一点的像素坐标"></a>8. 获取屏幕上某一点的像素坐标</h5><p>使用snipaste软件，启动在后台运行，需要时点击F1进入截图预览模式，此时鼠标所处的位置会有坐标值显示。<br>或者使用<code>pyautogui.displayMousePosition()</code>实时显示位置和颜色信息。</p>
<h5 id="9-获取屏幕图像信息"><a href="#9-获取屏幕图像信息" class="headerlink" title="9. 获取屏幕图像信息"></a>9. 获取屏幕图像信息</h5><p>使用<code>pyautogui.screenshot()</code>获取全屏截图。使用<code>pyautogui.pixel(x, y)</code>获取某个像素点的颜色信息输入两个坐标值。<br>判断某个点是否与给定颜色一致，可用<code>pyautogui.pixelMatchesColor(x, y, (R, G, B))</code>，输入两个坐标值，和一个包含RGB信息的元组。<br>判断给定的图片在屏幕上的哪个位置，可用<code>pyautogui.locateOnScreen(&#39;img.jpg&#39;)</code>，传入参数为图片路径，返回xywh元组，可能有多个。如果想要点击这个区域的中心，将该元组传入<code>pyautogui.click((x, y, w, h))</code>即可。甚至可以直接这样<code>pyautogui.click(&#39;img.jpg&#39;)</code>实现查找和点击，但是有可能不成功，需和<code>try</code>以及<code>except</code>一起用。</p>
<h5 id="10-获取窗口信息"><a href="#10-获取窗口信息" class="headerlink" title="10. 获取窗口信息"></a>10. 获取窗口信息</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line">fw = pyautogui.getActiveWindow() <span class="comment"># 获取活动的窗口信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(fw))  <span class="comment"># &lt;Win32Window left=&quot;-12&quot;, top=&quot;-12&quot;, width=&quot;2584&quot;, height=&quot;1540&quot;, title=&quot;test.py - Visual Studio Code&quot;&gt;</span></span><br><span class="line"></span><br><span class="line">pyautogui.getAllWindows() <span class="comment"># 返回一个list，包含所有的窗口信息</span></span><br><span class="line"></span><br><span class="line">pyautogui.getWindowsAt(x, y) <span class="comment"># 输入xy坐标，返回包含坐标的所有窗口</span></span><br><span class="line"></span><br><span class="line">pyautogui.getWindowsWithTitle(title) <span class="comment"># 输入title，返回对应的窗口</span></span><br><span class="line"></span><br><span class="line">pyautogui.getAllTitles() <span class="comment"># 获取所有的串口标题，返回是一个list，元素为string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对获取到的窗口可以进行一些操作</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fw.width = <span class="number">1000</span> <span class="comment"># 将窗口宽度调整为1000像素</span></span><br><span class="line"></span><br><span class="line">fw.topleft = (<span class="number">200</span>, <span class="number">200</span>) <span class="comment"># 将窗口左上角移动到指定位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fw.isMaximized) <span class="comment"># 判断窗口是否为最大化</span></span><br><span class="line"></span><br><span class="line">fw.maximize() <span class="comment"># 最大化窗口</span></span><br><span class="line"></span><br><span class="line">fw.minimize() <span class="comment"># 最小化窗口</span></span><br><span class="line"></span><br><span class="line">fw.restore()  <span class="comment"># 恢复最大化/最小化操作</span></span><br></pre></td></tr></table></figure>
<p>完整的使用方法，见官方文档<a target="_blank" rel="noopener" href="https://pyautogui.readthedocs.io/">https://pyautogui.readthedocs.io/</a></p>
<h4 id="二、控制键盘"><a href="#二、控制键盘" class="headerlink" title="二、控制键盘"></a>二、控制键盘</h4><h5 id="1-输入内容"><a href="#1-输入内容" class="headerlink" title="1. 输入内容"></a>1. 输入内容</h5><p>首先通过点击确定文字输入区域，再用<code>pyautogui.write()</code>输入。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line">pyautogui.click(<span class="number">1080</span>,<span class="number">1400</span>)</span><br><span class="line">pyautogui.write(<span class="string">&#x27;hello world!&#x27;</span>) <span class="comment"># pyautogui输入&#x27;!&#x27;时会自动按下shift键</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用list传入时可以将键盘上的所有键以名称方式描述，如&#x27;left&#x27;表←键</span></span><br><span class="line">pyautogui.write([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>]) <span class="comment"># 按顺序按下a、b、←、←、shift+x、shift+y 结果 XYab</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>键盘对应的内容表格如下</p>
<table>
<thead>
<tr>
<th>键盘关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>‘a’, ‘b’, ‘c’, ‘A’, ‘B’, ‘C’, ‘1’, ‘2’, ‘3’, ‘!’, ‘@’, ‘#’等</td>
<td>单字符按键</td>
</tr>
<tr>
<td>‘enter’ (或 ‘return’ 或 ‘\n’)</td>
<td>回车键</td>
</tr>
<tr>
<td>‘esc’</td>
<td>ESC键</td>
</tr>
<tr>
<td>‘shiftleft’, ‘shiftright’</td>
<td>左右SHIFT键</td>
</tr>
<tr>
<td>‘altleft’, ‘altright’</td>
<td>左右ALT键</td>
</tr>
<tr>
<td>‘ctrlleft’, ‘ctrlright’</td>
<td>左右CTRL键</td>
</tr>
<tr>
<td>‘tab’ (或 ‘\t’)</td>
<td>TAB键</td>
</tr>
<tr>
<td>‘backspace’, ‘delete’</td>
<td>BACKSPACE 和 DELETE键</td>
</tr>
<tr>
<td>‘pageup’, ‘pagedown’</td>
<td>PAGE UP 和 PAGE DOWN 键</td>
</tr>
<tr>
<td>‘home’, ‘end’</td>
<td>HOME 和 END 键</td>
</tr>
<tr>
<td>‘up’, ‘down’, ‘left’, ‘right’</td>
<td>up, down, left 和 right 箭头键</td>
</tr>
<tr>
<td>‘f1’, ‘f2’, ‘f3’, 等</td>
<td>F1 到 F12 键</td>
</tr>
<tr>
<td>‘volumemute’, ‘volumedown’, ‘volumeup’</td>
<td>静音，音量减，音量加键（有些键盘没有这些键，但是你的电脑可以接收这些指令）</td>
</tr>
<tr>
<td>‘pause’</td>
<td>PAUSE键</td>
</tr>
<tr>
<td>‘capslock’, ‘numlock’, ‘scrolllock’</td>
<td>CAPS LOCK, NUM LOCK, 和 SCROLL LOCK 键</td>
</tr>
<tr>
<td>‘insert’</td>
<td>INS 或 INSERT 键</td>
</tr>
<tr>
<td>‘printscreen’</td>
<td>PRTSC 或 PRINT SCREEN 键</td>
</tr>
<tr>
<td>‘winleft’, ‘winright’</td>
<td>左右WIN键(Windows)</td>
</tr>
<tr>
<td>‘command’</td>
<td>Command键(macOS)</td>
</tr>
<tr>
<td>‘option’</td>
<td>OPTION键(on macOS)</td>
</tr>
</tbody></table>
<h5 id="2-热键组合"><a href="#2-热键组合" class="headerlink" title="2. 热键组合"></a>2. 热键组合</h5><p>与鼠标相似，我们可以用<code>pyautogui.keyDown()</code>和<code>pyautogui.keyUp()</code>来分开控制键盘的按下与释放。<br>如在windows上实现一次复制粘贴，可以如下操作</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.keyDown(<span class="string">&#x27;ctrl&#x27;</span>)</span><br><span class="line">pyautogui.keyDown(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">pyautogui.keyUp(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">pyautogui.keyUp(<span class="string">&#x27;ctrl&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>但是上面的操作未免有些复杂了，同样的操作可以这样</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.hotkey(<span class="string">&#x27;ctrl&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="3-使用提示"><a href="#3-使用提示" class="headerlink" title="3. 使用提示"></a>3. 使用提示</h5><ul>
<li>屏幕分辨率保持不便</li>
<li>应用窗口应该最大化，因为这样才能保证按钮始终在同一个位置</li>
<li>根据软件反应速度多给一些延时，你不会想在上一个动作没有完成就开始点击</li>
<li>使用<code>locateOnScreen()</code>寻找按钮，尽量不依赖xy坐标，在没发现目标时停止比乱点击要好</li>
<li>使用<code>getWindowsWithTitle()</code>确保你准备控制的应用程序窗口是存在的，用<code>activate()</code>让窗口进入前台</li>
<li>增加尽可能多的检查，如弹窗、断网的情况怎么处理</li>
<li>第一次运行时要完整地观察是否正常</li>
</ul>
<p>给延时的两个例子</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">3</span>)   <span class="comment"># 等待3s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line">pyautogui.countdown(<span class="number">10</span>) <span class="comment"># 等待10s，在命令行倒数输出10、9、8...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外可以用<code>pyautogui.alert(&#39;text&#39;)</code>或<code>pyautogui.confirm(&#39;text&#39;)</code>来弹窗确认。如果需要使用到剪贴板里面的内容，需要用到<code>import pyperclip</code>然后<code>pyperclip.paste()</code></p>
<blockquote>
<p>关于计算机道德<br>为善去恶，学会这项技术的目的应该是提高自己的生产效率，勿做有损他人的事情。</p>
</blockquote>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>[1] <a target="_blank" rel="noopener" href="https://automatetheboringstuff.com/2e/chapter20/">Automate The Boring Stuff, Al Sweigart</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://debugtheuniverse.github.io/2024/03/14/pyautogui/" data-id="cltse7fc20000wkukdvvh8w6f" data-title="pyautogui" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-你好世界" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/11/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/" class="article-date">
  <time class="dt-published" datetime="2024-03-11T12:51:38.823Z" itemprop="datePublished">2024-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/11/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/">你好世界！</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>欢迎来到黄河水澄的技术专栏！<br>这里会分享我学习过程中的一些技术笔记，目的是督促自己学习、分享有用的知识。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://debugtheuniverse.github.io/2024/03/11/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/" data-id="cltmz32ci0000wsukh49adlx5" data-title="你好世界！" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/01/OpenCV%20%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D/">OpenCV 特征匹配</a>
          </li>
        
          <li>
            <a href="/2024/03/28/OpenCV%20%E7%9B%B8%E6%9C%BA%E7%95%B8%E5%8F%98%E6%A0%A1%E5%87%86/">OpenCV相机畸变校准</a>
          </li>
        
          <li>
            <a href="/2024/03/21/OpenCV%20%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/">OpenCV 特征提取与描述</a>
          </li>
        
          <li>
            <a href="/2024/03/20/OpenCV%20%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">OpenCV 图像处理</a>
          </li>
        
          <li>
            <a href="/2024/03/20/OpenCV%20%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/">OpenCV 快速使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Jim Huang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>